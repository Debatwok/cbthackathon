"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LuisAdaptiveRecognizer = void 0;
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const luisAdaptivePredictionOptions_1 = require("./luisAdaptivePredictionOptions");
const luisRecognizer_1 = require("./luisRecognizer");
const luisTelemetryConstants_1 = require("./luisTelemetryConstants");
/**
 * Class that represents an adaptive LUIS recognizer.
 */
class LuisAdaptiveRecognizer extends botbuilder_dialogs_1.Recognizer {
    constructor() {
        super(...arguments);
        /**
         * The flag to indicate in personal information should be logged in telemetry.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.runtimeSettings.telemetry.logPersonalInformation');
    }
    getConverter(property) {
        switch (property) {
            case 'applicationId':
            case 'version':
            case 'endpoint':
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'dynamicLists':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'predictionOptions':
                return new luisAdaptivePredictionOptions_1.LuisAdaptivePredictionOptionsConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * To recognize intents and entities in a users utterance.
     *
     * @param {DialogContext} dialogContext The [DialogContext](xref:botbuilder-dialogs.DialogContext).
     * @param {Activity} activity The [Activity](xref:botbuilder-core.Activity).
     * @param {object} telemetryProperties Optional. Additional properties to be logged to telemetry with event.
     * @param {object} telemetryMetrics Optional. Additional metrics to be logged to telemetry with event.
     * @returns {Promise<RecognizerResult>} A promise resolving to the recognizer result.
     */
    recognize(dialogContext, activity, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate passed in activity matches turn activity
            const context = dialogContext.context;
            const utteranceMatches = !activity || (context.activity.type === activity.type && context.activity.text === activity.text);
            if (!utteranceMatches) {
                throw new Error(`TurnContext is different than text`);
            }
            // Initialize application info
            const dcState = dialogContext.state;
            const application = {
                applicationId: this.applicationId.getValue(dcState),
                endpoint: this.endpoint.getValue(dcState),
                endpointKey: this.endpointKey.getValue(dcState),
            };
            // Create and call wrapper
            const recognizer = new luisRecognizer_1.LuisRecognizer(application, this.recognizerOptions(dialogContext));
            const result = yield recognizer.recognize(dialogContext);
            this.trackRecognizerResult(dialogContext, 'LuisResult', this.fillRecognizerResultTelemetryProperties(result, telemetryProperties, dialogContext), telemetryMetrics);
            return result;
        });
    }
    /**
     * Construct V3 recognizer options from the current dialog context.
     *
     * @param {DialogContext} dialogContext Current dialog context.
     * @returns {LuisRecognizerOptionsV3} luis recognizer options
     */
    recognizerOptions(dialogContext) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const options = {
            apiVersion: 'v3',
            externalEntityRecognizer: this.externalEntityRecognizer,
            telemetryClient: this.telemetryClient,
            includeAllIntents: false,
            includeInstanceData: false,
            includeAPIResults: false,
            log: true,
            preferExternalEntities: true,
            slot: 'production',
        };
        const dcState = dialogContext.state;
        if (this.predictionOptions) {
            options.datetimeReference = (_a = this.predictionOptions.dateTimeReference) === null || _a === void 0 ? void 0 : _a.getValue(dcState);
            options.externalEntities = (_b = this.predictionOptions.externalEntities) === null || _b === void 0 ? void 0 : _b.getValue(dcState);
            options.includeAllIntents = (_d = (_c = this.predictionOptions.includeAllIntents) === null || _c === void 0 ? void 0 : _c.getValue(dcState)) !== null && _d !== void 0 ? _d : false;
            options.includeInstanceData = (_f = (_e = this.predictionOptions.includeInstanceData) === null || _e === void 0 ? void 0 : _e.getValue(dcState)) !== null && _f !== void 0 ? _f : true;
            options.includeAPIResults = (_h = (_g = this.predictionOptions.includeAPIResults) === null || _g === void 0 ? void 0 : _g.getValue(dcState)) !== null && _h !== void 0 ? _h : false;
            options.log = (_k = (_j = this.predictionOptions.log) === null || _j === void 0 ? void 0 : _j.getValue(dcState)) !== null && _k !== void 0 ? _k : true;
            options.preferExternalEntities = (_m = (_l = this.predictionOptions.preferExternalEntities) === null || _l === void 0 ? void 0 : _l.getValue(dcState)) !== null && _m !== void 0 ? _m : true;
            options.slot = ((_o = this.predictionOptions.slot) === null || _o === void 0 ? void 0 : _o.getValue(dcState)) === 'staging' ? 'staging' : 'production';
        }
        if (this.version) {
            options.version = this.version.getValue(dcState);
        }
        if (this.dynamicLists) {
            options.dynamicLists = this.dynamicLists.getValue(dcState).map((item) => ({
                listEntityName: item.entity,
                requestLists: item.list,
            }));
        }
        return options;
    }
    /**
     * Fills the event properties for LuisResult event for telemetry.
     * These properties are logged when the recognizer is called.
     *
     * @param {RecognizerResult} recognizerResult Last activity sent from user.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @param {DialogContext} dialogContext Dialog context.
     * @returns {object} A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the LuisResult event.
     */
    fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dialogContext) {
        var _a, _b, _c, _d;
        const logPersonalInfo = this.logPersonalInformation.tryGetValue(dialogContext.state);
        const applicationId = this.applicationId.tryGetValue(dialogContext.state);
        const [firstIntent, secondIntent] = luisRecognizer_1.LuisRecognizer.sortedIntents(recognizerResult);
        // Add the intent score and conversation id properties
        const properties = {};
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.applicationIdProperty] = applicationId.value;
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentProperty] = (_a = firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.intent) !== null && _a !== void 0 ? _a : '';
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentScoreProperty] = ((_b = firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.score) !== null && _b !== void 0 ? _b : 0).toString();
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intent2Property] = (_c = secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.intent) !== null && _c !== void 0 ? _c : '';
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentScore2Property] = ((_d = secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.score) !== null && _d !== void 0 ? _d : 0).toString();
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.fromIdProperty] = dialogContext.context.activity.from.id;
        if (recognizerResult.sentiment) {
            if (recognizerResult.sentiment.label) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentLabelProperty] = recognizerResult.sentiment.label;
            }
            if (recognizerResult.sentiment.score) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentScoreProperty] = recognizerResult.sentiment.score.toString();
            }
        }
        // Log entity names
        if (recognizerResult.entities) {
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.entitiesProperty] = JSON.stringify(recognizerResult.entities);
        }
        // Use the logPersonalInfo flag to toggle logging PII data, text is a common example
        if (logPersonalInfo.value && dialogContext.context.activity.text) {
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.questionProperty] = dialogContext.context.activity.text;
        }
        // Additional Properties can override "stock" properties.
        if (telemetryProperties) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
}
exports.LuisAdaptiveRecognizer = LuisAdaptiveRecognizer;
LuisAdaptiveRecognizer.$kind = 'Microsoft.LuisRecognizer';
//# sourceMappingURL=luisAdaptiveRecognizer.js.map