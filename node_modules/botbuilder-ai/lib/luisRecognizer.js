"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LuisRecognizer = void 0;
const url_parse_1 = __importDefault(require("url-parse"));
const botbuilder_core_1 = require("botbuilder-core");
const luisTelemetryConstants_1 = require("./luisTelemetryConstants");
const luisRecognizerOptionsV2_1 = require("./luisRecognizerOptionsV2");
const luisRecognizerOptionsV3_1 = require("./luisRecognizerOptionsV3");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const z = __importStar(require("zod"));
// This zod type is purely used for type assertions in a scenario where we
// know better than the compiler does that we'll have a value of this type.
// This is just meant to operate as a simple type assertion.
const UnsafeLuisRecognizerUnion = z.custom((val) => z.record(z.unknown()).check(val), {
    message: 'LuisRecognizerOptionsV3 | LuisRecognizerOptionsV2 | LuisPredictionOptions',
});
/**
 * Recognize intents in a user utterance using a configured LUIS model.
 *
 * @summary
 * This class is used to recognize intents and extract entities from incoming messages.
 * See this class in action [in this sample application](https://github.com/microsoft/BotBuilder-Samples/tree/main/samples/javascript_nodejs/14.nlp-with-dispatch).
 *
 * This component can be used within your bots logic by calling [recognize()](#recognize).
 */
class LuisRecognizer {
    /**
     * Creates a new [LuisRecognizer](xref:botbuilder-ai.LuisRecognizer) instance.
     *
     * @param {LuisApplication | string} application An object conforming to the [LuisApplication](xref:botbuilder-ai.LuisApplication) definition or a string representing a LUIS application endpoint, usually retrieved from https://luis.ai.
     * @param {LuisRecognizerOptionsV3 | LuisRecognizerOptionsV2 | LuisPredictionOptions} options Optional. Options object used to control predictions. Should conform to the [LuisPredictionOptions](xref:botbuilder-ai.LuisPredictionOptions), [LuisRecognizerOptionsV3](xref:botbuilder-ai.LuisRecognizerOptionsV3) or [LuisRecognizerOptionsV2](xref:botbuilder-ai.LuisRecognizerOptionsV2) definition.
     * @param {boolean} includeApiResults (Deprecated) Flag that if set to `true` will force the inclusion of LUIS Api call in results returned by the [LuisRecognizer.recognize](xref:botbuilder-ai.LuisRecognizer.recognize) method. Defaults to a value of `false`.
     */
    constructor(application, options, includeApiResults) {
        this.cacheKey = Symbol('results');
        if (typeof application === 'string') {
            const parsedEndpoint = url_parse_1.default(application);
            // Use exposed querystringify to parse the query string for the endpointKey value.
            const parsedQuery = url_parse_1.default.qs.parse(parsedEndpoint.query);
            this.application = {
                applicationId: parsedEndpoint.pathname.split('apps/')[1],
                // Note: The query string parser bundled with url-parse can return "null" as a value for the origin.
                endpoint: parsedEndpoint.origin,
                endpointKey: parsedQuery['subscription-key'],
            };
        }
        else {
            const { applicationId, endpoint, endpointKey } = application;
            this.application = {
                applicationId: applicationId,
                endpoint: endpoint,
                endpointKey: endpointKey,
            };
        }
        this.validateLuisApplication();
        this._telemetryClient = (options && options.telemetryClient) || new botbuilder_core_1.NullTelemetryClient();
        this._logPersonalInformation = (options && options.logPersonalInformation) || false;
        if (!options) {
            this.luisRecognizerInternal = new luisRecognizerOptionsV2_1.LuisRecognizerV2(this.application);
        }
        else if (luisRecognizerOptionsV3_1.isLuisRecognizerOptionsV3(options)) {
            this.luisRecognizerInternal = new luisRecognizerOptionsV3_1.LuisRecognizerV3(this.application, options);
        }
        else if (luisRecognizerOptionsV2_1.isLuisRecognizerOptionsV2(options)) {
            this.luisRecognizerInternal = new luisRecognizerOptionsV2_1.LuisRecognizerV2(this.application, options);
        }
        else {
            this.options = Object.assign({}, options);
            const recOptions = Object.assign(Object.assign({ includeAPIResults: !!includeApiResults }, options), { apiVersion: 'v2' });
            this.luisRecognizerInternal = new luisRecognizerOptionsV2_1.LuisRecognizerV2(this.application, recOptions);
        }
    }
    // Gets a value indicating whether determines whether to log personal information that came from the user.
    get logPersonalInformation() {
        return this._logPersonalInformation;
    }
    // Gets the currently configured botTelemetryClient that logs the events.
    get telemetryClient() {
        return this._telemetryClient;
    }
    /**
     * Returns the name of the top scoring intent from a set of LUIS results.
     *
     * @param {RecognizerResult} results Result set to be searched.
     * @param {string} defaultIntent (Optional) intent name to return should a top intent be found. Defaults to a value of `None`.
     * @param {number} minScore (Optional) minimum score needed for an intent to be considered as a top intent. If all intents in the set are below this threshold then the `defaultIntent` will be returned.  Defaults to a value of `0.0`.
     * @returns {string} the top intent
     */
    static topIntent(results, defaultIntent = 'None', minScore = 0) {
        const sortedIntents = this.sortedIntents(results, minScore);
        const topIntent = sortedIntents[0];
        return (topIntent === null || topIntent === void 0 ? void 0 : topIntent.intent) || defaultIntent; // Note: `||` is intentionally not `??` and is covered by tests
    }
    /**
     * Sorts recognizer result intents in ascending order by score, filtering those that
     * have scores less that `minScore`.
     *
     * @param {RecognizerResult} result recognizer result to be sorted and filtered
     * @param {number} minScore minimum score threshold, lower score results will be filtered
     * @returns {Array<{intent: string; score: number}>} sorted result intents
     */
    static sortedIntents(result, minScore = 0) {
        var _a;
        return Object.entries((_a = result === null || result === void 0 ? void 0 : result.intents) !== null && _a !== void 0 ? _a : {})
            .map(([intent, { score = 0 }]) => ({ intent, score }))
            .filter(({ score }) => score > minScore)
            .sort(({ score: left }, { score: right }) => {
            if (left > right) {
                return -1;
            }
            else if (left < right) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    /**
     * @internal
     */
    recognize(contextOrUtterance, maybeTelemetryPropertiesOrOptions, maybeTelemetryMetrics, maybeOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            // This type check, when true, logically implies that the function is being invoked as the two-argument string + optional options overload variant.
            if (typeof contextOrUtterance === 'string') {
                const utterance = contextOrUtterance;
                const options = UnsafeLuisRecognizerUnion.optional().nullable().parse(maybeTelemetryPropertiesOrOptions);
                const luisRecognizer = options ? this.buildRecognizer(options) : this.luisRecognizerInternal;
                return luisRecognizer.recognizeInternal(utterance);
            }
            else {
                const telemetryProperties = z
                    .record(z.string())
                    .optional()
                    .nullable()
                    .parse(maybeTelemetryPropertiesOrOptions);
                const turnContext = contextOrUtterance instanceof botbuilder_dialogs_1.DialogContext ? contextOrUtterance.context : contextOrUtterance;
                const cached = turnContext.turnState.get(this.cacheKey);
                if (!cached) {
                    const utterance = turnContext.activity.text || '';
                    let recognizerPromise;
                    if (!utterance.trim()) {
                        // Bypass LUIS if the activity's text is null or whitespace
                        recognizerPromise = Promise.resolve({
                            text: utterance,
                            intents: { '': { score: 1 } },
                            entities: {},
                        });
                    }
                    else {
                        const luisRecognizer = maybeOptions
                            ? this.buildRecognizer(maybeOptions)
                            : this.luisRecognizerInternal;
                        recognizerPromise = luisRecognizer.recognizeInternal(turnContext);
                    }
                    try {
                        const recognizerResult = yield recognizerPromise;
                        // Write to cache
                        turnContext.turnState.set(this.cacheKey, recognizerResult);
                        // Log telemetry
                        this.onRecognizerResults(recognizerResult, turnContext, telemetryProperties, maybeTelemetryMetrics);
                        return recognizerResult;
                    }
                    catch (error) {
                        this.prepareErrorMessage(error);
                        throw error;
                    }
                }
                return cached;
            }
        });
    }
    /**
     * Invoked prior to a LuisResult Event being logged.
     *
     * @param {RecognizerResult} recognizerResult The Luis Results for the call.
     * @param {TurnContext} turnContext Context object containing information for a single turn of conversation with a user.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @param {object} telemetryMetrics Additional metrics to be logged to telemetry with the LuisResult event.
     */
    onRecognizerResults(recognizerResult, turnContext, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fillTelemetryProperties(recognizerResult, turnContext, telemetryProperties).then((props) => {
                this.telemetryClient.trackEvent({
                    name: luisTelemetryConstants_1.LuisTelemetryConstants.luisResultEvent,
                    properties: props,
                    metrics: telemetryMetrics,
                });
            });
        });
    }
    /**
     * Fills the event properties for LuisResult event for telemetry. These properties are logged when the recognizer is called.
     *
     * @param {RecognizerResult} recognizerResult Last activity sent from user.
     * @param {TurnContext} turnContext Context object containing information for a single turn of conversation with a user.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @returns {Promise<object>} A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the LuisResult event.
     */
    fillTelemetryProperties(recognizerResult, turnContext, telemetryProperties) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const [firstIntent, secondIntent] = LuisRecognizer.sortedIntents(recognizerResult);
            // Add the intent score and conversation id properties
            const properties = {};
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.applicationIdProperty] = this.application.applicationId;
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentProperty] = (_a = firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.intent) !== null && _a !== void 0 ? _a : '';
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentScoreProperty] = ((_b = firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.score) !== null && _b !== void 0 ? _b : 0).toString();
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.intent2Property] = (_c = secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.intent) !== null && _c !== void 0 ? _c : '';
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentScore2Property] = ((_d = secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.score) !== null && _d !== void 0 ? _d : 0).toString();
            if (turnContext.activity.from) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.fromIdProperty] = turnContext.activity.from.id;
            }
            if (recognizerResult.sentiment) {
                if (recognizerResult.sentiment.label) {
                    properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentLabelProperty] = recognizerResult.sentiment.label;
                }
                if (recognizerResult.sentiment.score) {
                    properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentScoreProperty] = recognizerResult.sentiment.score.toString();
                }
            }
            // Log entity names
            if (recognizerResult.entities) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.entitiesProperty] = JSON.stringify(recognizerResult.entities);
            }
            // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example
            if (this.logPersonalInformation && turnContext.activity.text) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.questionProperty] = turnContext.activity.text;
            }
            // Additional Properties can override "stock" properties.
            if (telemetryProperties != null) {
                return Object.assign({}, properties, telemetryProperties);
            }
            return properties;
        });
    }
    prepareErrorMessage(error) {
        // If the `error` received is a azure-cognitiveservices-luis-runtime error,
        // it may have a `response` property and `response.statusCode`.
        // If these properties exist, we should populate the error with a correct and informative error message.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const response = error.response;
        if (response === null || response === void 0 ? void 0 : response.status) {
            switch (response.status) {
                case 400:
                    error.message = [
                        `Response 400: The request's body or parameters are incorrect,`,
                        `meaning they are missing, malformed, or too large.`,
                    ].join(' ');
                    break;
                case 401:
                    error.message = `Response 401: The key used is invalid, malformed, empty, or doesn't match the region.`;
                    break;
                case 403:
                    error.message = `Response 403: Total monthly key quota limit exceeded.`;
                    break;
                case 409:
                    error.message = `Response 409: Application loading in progress, please try again.`;
                    break;
                case 410:
                    error.message = `Response 410: Please retrain and republish your application.`;
                    break;
                case 414:
                    error.message = `Response 414: The query is too long. Please reduce the query length to 500 or less characters.`;
                    break;
                case 429:
                    error.message = `Response 429: Too many requests.`;
                    break;
                default:
                    error.message = [
                        `Response ${response.status}: Unexpected status code received.`,
                        `Please verify that your LUIS application is properly setup.`,
                    ].join(' ');
            }
        }
    }
    // Merges the default options set by the Recognizer contructor with the 'user' options passed into the 'recognize' method
    setLuisPredictionOptions(defaultOptions, userOptions) {
        return Object.assign(defaultOptions, userOptions);
    }
    // Performs a series of valdiations on `LuisRecognizer.application`.
    // Note: Neither the LUIS Application ID nor the Endpoint Key are actual LUIS components, they are representations of what two valid values would appear as.
    validateLuisApplication() {
        if (!this.application.applicationId) {
            throw new Error(`Invalid \`applicationId\` value detected: ${this.application.applicationId}\nPlease make sure your applicationId is a valid LUIS Application Id, e.g. "b31aeaf3-3511-495b-a07f-571fc873214b".`);
        }
        if (!this.application.endpointKey) {
            throw new Error(`Invalid \`endpointKey\` value detected: ${this.application.endpointKey}\nPlease make sure your endpointKey is a valid LUIS Endpoint Key, e.g. "048ec46dc58e495482b0c447cfdbd291".`);
        }
    }
    // Builds a LuisRecognizer Strategy depending on the options passed
    buildRecognizer(userOptions) {
        if (luisRecognizerOptionsV3_1.isLuisRecognizerOptionsV3(userOptions)) {
            return new luisRecognizerOptionsV3_1.LuisRecognizerV3(this.application, userOptions);
        }
        else if (luisRecognizerOptionsV2_1.isLuisRecognizerOptionsV2(userOptions)) {
            return new luisRecognizerOptionsV2_1.LuisRecognizerV2(this.application, userOptions);
        }
        else {
            if (!this.options) {
                this.options = {};
            }
            const merge = Object.assign(this.options, userOptions);
            const recOptions = Object.assign(Object.assign({}, merge), { apiVersion: 'v2' });
            return new luisRecognizerOptionsV2_1.LuisRecognizerV2(this.application, recOptions);
        }
    }
}
exports.LuisRecognizer = LuisRecognizer;
//# sourceMappingURL=luisRecognizer.js.map