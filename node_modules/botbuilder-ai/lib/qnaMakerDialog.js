"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QnAMakerDialog = void 0;
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_core_1 = require("botbuilder-core");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const botbuilder_stdlib_1 = require("botbuilder-stdlib");
const _1 = require("./");
const qnaCardBuilder_1 = require("./qnaCardBuilder");
const qnaMaker_1 = require("./qnaMaker");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const qnamaker_utils_1 = require("./qnamaker-utils");
class QnAMakerDialogActivityConverter {
    convert(value) {
        if (typeof value === 'string') {
            return new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(value));
        }
        return value;
    }
}
const isSuggestionsFactory = (val) => {
    return botbuilder_stdlib_1.tests.isFunc(val);
};
/**
 * A dialog that supports multi-step and adaptive-learning QnA Maker services.
 *
 * @summary
 * An instance of this class targets a specific QnA Maker knowledge base.
 * It supports knowledge bases that include follow-up prompt and active learning features.
 * The dialog will also present user with appropriate multi-turn prompt or active learning options.
 */
class QnAMakerDialog extends botbuilder_dialogs_1.WaterfallDialog {
    /**
     * @internal
     */
    constructor(knowledgeBaseId, endpointKey, hostname, noAnswer, threshold, activeLearningTitleOrFactory, cardNoMatchText, top, cardNoMatchResponse, strictFilters, dialogId = 'QnAMakerDialog', 
    // TODO: Should member exist in QnAMakerDialogConfiguration?
    //       And be of type `string | JoinOperator | Expression | EnumExpression<JoinOperator>`?
    strictFiltersJoinOperator) {
        super(dialogId);
        this.strictFiltersJoinOperator = strictFiltersJoinOperator;
        // state and step value key constants
        /**
         * The path for storing and retrieving QnA Maker context data.
         *
         * @summary
         * This represents context about the current or previous call to QnA Maker.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.qnAContextData = 'previousContextData';
        /**
         * The path for storing and retrieving the previous question ID.
         *
         * @summary
         * This represents the QnA question ID from the previous turn.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.previousQnAId = 'previousQnAId';
        /**
         * The path for storing and retrieving the options for this instance of the dialog.
         *
         * @summary
         * This includes the options with which the dialog was started and options expected by the QnA Maker service.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker and the dialog system.
         */
        this.options = 'options';
        // Dialog options parameters
        /**
         * The default threshold for answers returned, based on score.
         */
        this.defaultThreshold = 0.3;
        /**
         * The default maximum number of answers to be returned for the question.
         */
        this.defaultTopN = 3;
        this.currentQuery = 'currentQuery';
        this.qnAData = 'qnaData';
        this.defaultNoAnswer = 'No QnAMaker answers found.';
        // Card parameters
        this.defaultCardTitle = 'Did you mean:';
        this.defaultCardNoMatchText = 'None of the above.';
        this.defaultCardNoMatchResponse = 'Thanks for the feedback.';
        /**
         * Gets or sets the threshold for answers returned, based on score.
         */
        this.threshold = new adaptive_expressions_1.NumberExpression(this.defaultThreshold);
        /**
         * Gets or sets the maximum number of answers to return from the knowledge base.
         */
        this.top = new adaptive_expressions_1.IntExpression(this.defaultTopN);
        /**
         * Gets or sets the template to send to the user when QnA Maker does not find an answer.
         */
        this.noAnswer = new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultNoAnswer));
        /**
         * Gets or sets the template to send to the user if they select the no match option on an
         * active learning card.
         */
        this.cardNoMatchResponse = new qnamaker_utils_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultCardNoMatchResponse));
        /**
         * Gets or sets the flag to determine if personal information should be logged in telemetry.
         *
         * @summary
         * Defaults to a value of `=settings.telemetry.logPersonalInformation`, which retrieves
         * `logPersonalInformation` flag from settings.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.runtimeSettings.telemetry.logPersonalInformation');
        /**
         * Gets or sets a value indicating whether gets or sets environment of knowledgebase to be called.
         */
        this.isTest = false;
        /**
         * Gets or sets the QnA Maker ranker type to use.
         */
        this.rankerType = new adaptive_expressions_1.EnumExpression(qnamaker_interfaces_1.RankerTypes.default);
        if (knowledgeBaseId) {
            this.knowledgeBaseId = new adaptive_expressions_1.StringExpression(knowledgeBaseId);
        }
        if (endpointKey) {
            this.endpointKey = new adaptive_expressions_1.StringExpression(endpointKey);
        }
        if (hostname) {
            this.hostname = new adaptive_expressions_1.StringExpression(hostname);
        }
        if (threshold) {
            this.threshold = new adaptive_expressions_1.NumberExpression(threshold);
        }
        if (top) {
            this.top = new adaptive_expressions_1.IntExpression(top);
        }
        if (isSuggestionsFactory(activeLearningTitleOrFactory)) {
            if (!cardNoMatchText) {
                // Without a developer-provided cardNoMatchText, the end user will not be able to tell the convey to the bot and QnA Maker that the suggested alternative questions were not correct.
                // When the user's reply to a suggested alternatives Activity matches the cardNoMatchText, the QnAMakerDialog sends this information to the QnA Maker service for active learning.
                throw new Error('cardNoMatchText is required when using the suggestionsActivityFactory.');
            }
            this.suggestionsActivityFactory = activeLearningTitleOrFactory;
        }
        else {
            this.activeLearningCardTitle = new adaptive_expressions_1.StringExpression(activeLearningTitleOrFactory !== null && activeLearningTitleOrFactory !== void 0 ? activeLearningTitleOrFactory : this.defaultCardTitle);
        }
        if (cardNoMatchText) {
            this.cardNoMatchText = new adaptive_expressions_1.StringExpression(cardNoMatchText);
        }
        if (strictFilters) {
            this.strictFilters = new adaptive_expressions_1.ArrayExpression(strictFilters);
        }
        if (noAnswer) {
            this.noAnswer = new qnamaker_utils_1.BindToActivity(noAnswer);
        }
        this.cardNoMatchResponse = new qnamaker_utils_1.BindToActivity(cardNoMatchResponse !== null && cardNoMatchResponse !== void 0 ? cardNoMatchResponse : botbuilder_core_1.MessageFactory.text(this.defaultCardNoMatchResponse));
        this.addStep(this.callGenerateAnswer.bind(this));
        this.addStep(this.callTrain.bind(this));
        this.addStep(this.checkForMultiTurnPrompt.bind(this));
        this.addStep(this.displayQnAResult.bind(this));
    }
    getConverter(property) {
        switch (property) {
            case 'knowledgeBaseId':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'hostname':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'threshold':
                return new adaptive_expressions_1.NumberExpressionConverter();
            case 'top':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'noAnswer':
                return new QnAMakerDialogActivityConverter();
            case 'activeLearningCardTitle':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchText':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchResponse':
                return new QnAMakerDialogActivityConverter();
            case 'strictFilters':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'rankerType':
                return new adaptive_expressions_1.EnumExpressionConverter(qnamaker_interfaces_1.RankerTypes);
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Called when the dialog is started and pushed onto the dialog stack.
     *
     * @summary
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     *
     * You can use the [options](#options) parameter to include the QnA Maker context data,
     * which represents context from the previous query. To do so, the value should include a
     * `context` property of type [QnAResponseContext](#QnAResponseContext).
     *
     * @param {DialogContext} dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param {object} options (Optional) Initial information to pass to the dialog.
     * @returns {Promise<DialogTurnResult>} A promise resolving to the turn result
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    beginDialog(dc, options) {
        const _super = Object.create(null, {
            beginDialog: { get: () => super.beginDialog }
        });
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!dc) {
                throw new Error('Missing DialogContext');
            }
            if (((_b = (_a = dc.context) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.type) !== botbuilder_core_1.ActivityTypes.Message) {
                return dc.endDialog();
            }
            const dialogOptions = {
                qnaDialogResponseOptions: yield this.getQnAResponseOptions(dc),
                qnaMakerOptions: yield this.getQnAMakerOptions(dc),
            };
            if (options) {
                Object.assign(dialogOptions, options);
            }
            return _super.beginDialog.call(this, dc, dialogOptions);
        });
    }
    /**
     * Called when the dialog is _continued_, where it is the active dialog and the
     * user replies with a new [Activity](xref:botframework-schema.Activity).
     *
     * @param {DialogContext} dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @returns {DialogContext} A Promise representing the asynchronous operation.
     */
    continueDialog(dc) {
        const interrupted = dc.state.getValue(botbuilder_dialogs_1.TurnPath.interrupted, false);
        if (interrupted) {
            // if qnamaker was interrupted then end the qnamaker dialog
            return dc.endDialog();
        }
        return super.continueDialog(dc);
    }
    /**
     * Called before an event is bubbled to its parent.
     *
     * @param {DialogContext} dc The dialog context for the current turn of conversation.
     * @param {DialogEvent} e The event being raised.
     * @returns {Promise<boolean>} Whether the event is handled by the current dialog and further processing should stop.
     */
    onPreBubbleEvent(dc, e) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            // When the DialogEvent.name is 'error', it's possible to end in a loop where events
            // keep firing if the error is encountered while trying to call QnA Maker.
            // If an error is encountered, forward it to this dialog's parent.
            if (e.name === 'error') {
                return this.onPostBubbleEvent(dc, e);
            }
            else if (((_b = (_a = dc.context) === null || _a === void 0 ? void 0 : _a.activity) === null || _b === void 0 ? void 0 : _b.type) === botbuilder_core_1.ActivityTypes.Message) {
                // decide whether we want to allow interruption or not.
                // if we don't get a response from QnA which signifies we expect it,
                // then we allow interruption.
                const reply = dc.context.activity.text;
                const dialogOptions = dc.activeDialog.state[this.options];
                if (reply.toLowerCase() === dialogOptions.qnaDialogResponseOptions.cardNoMatchText.toLowerCase()) {
                    // it matches nomatch text, we like that.
                    return true;
                }
                const suggestedQuestions = dc.state.getValue('this.suggestedQuestions');
                if (suggestedQuestions === null || suggestedQuestions === void 0 ? void 0 : suggestedQuestions.some((question) => question.toLowerCase() === reply.trim())) {
                    // it matches one of the suggested actions, we like that.
                    return true;
                }
                // Calling QnAMaker to get response.
                const qnaClient = yield this.getQnAMakerClient(dc);
                this.resetOptions(dc, dialogOptions);
                const response = yield qnaClient.getAnswersRaw(dc.context, dialogOptions.qnaMakerOptions);
                // disable interruption if we have answers.
                return (_d = ((_c = response.answers) === null || _c === void 0 ? void 0 : _c.length) > 0) !== null && _d !== void 0 ? _d : false;
            }
            // call base for default behavior.
            return this.onPostBubbleEvent(dc, e);
        });
    }
    /**
     * Gets an [QnAMakerClient](xref:botbuilder-ai.QnAMakerClient) to use to access the QnA Maker knowledge base.
     *
     * @param {DialogContext} dc The dialog context for the current turn of conversation.
     * @returns {Promise<QnAMakerClient>} A promise of QnA Maker instance.
     */
    getQnAMakerClient(dc) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const qnaClient = (_b = (_a = dc.context) === null || _a === void 0 ? void 0 : _a.turnState) === null || _b === void 0 ? void 0 : _b.get(qnaMaker_1.QnAMakerClientKey);
            if (qnaClient) {
                return qnaClient;
            }
            const endpoint = {
                knowledgeBaseId: this.knowledgeBaseId.getValue(dc.state),
                endpointKey: this.endpointKey.getValue(dc.state),
                host: this.getHost(dc),
            };
            const logPersonalInformation = this.logPersonalInformation instanceof adaptive_expressions_1.BoolExpression
                ? this.logPersonalInformation.getValue(dc.state)
                : this.logPersonalInformation;
            return new _1.QnAMaker(endpoint, yield this.getQnAMakerOptions(dc), this.telemetryClient, logPersonalInformation);
        });
    }
    /**
     * Gets the options for the QnA Maker client that the dialog will use to query the knowledge base.
     *
     * @param {DialogContext} dc The dialog context for the current turn of conversation.
     * @returns {Promise<QnAMakerOptions>} A promise of QnA Maker options to use.
     */
    getQnAMakerOptions(dc) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            return {
                scoreThreshold: (_b = (_a = this.threshold) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) !== null && _b !== void 0 ? _b : this.defaultThreshold,
                strictFilters: (_c = this.strictFilters) === null || _c === void 0 ? void 0 : _c.getValue(dc.state),
                top: (_e = (_d = this.top) === null || _d === void 0 ? void 0 : _d.getValue(dc.state)) !== null && _e !== void 0 ? _e : this.defaultTopN,
                qnaId: 0,
                rankerType: (_g = (_f = this.rankerType) === null || _f === void 0 ? void 0 : _f.getValue(dc.state)) !== null && _g !== void 0 ? _g : qnamaker_interfaces_1.RankerTypes.default,
                isTest: this.isTest,
                strictFiltersJoinOperator: this.strictFiltersJoinOperator,
            };
        });
    }
    /**
     * Gets the options the dialog will use to display query results to the user.
     *
     * @param {DialogContext} dc The dialog context for the current turn of conversation.
     * @returns {Promise<QnAMakerDialogResponseOptions>} A promise of QnA Maker response options to use.
     */
    getQnAResponseOptions(dc) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            return {
                activeLearningCardTitle: (_b = (_a = this.activeLearningCardTitle) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) !== null && _b !== void 0 ? _b : this.defaultCardTitle,
                cardNoMatchResponse: this.cardNoMatchResponse && (yield this.cardNoMatchResponse.bind(dc, dc.state)),
                cardNoMatchText: (_d = (_c = this.cardNoMatchText) === null || _c === void 0 ? void 0 : _c.getValue(dc.state)) !== null && _d !== void 0 ? _d : this.defaultCardNoMatchText,
                noAnswer: yield ((_e = this.noAnswer) === null || _e === void 0 ? void 0 : _e.bind(dc, dc.state)),
            };
        });
    }
    /**
     * Displays an appropriate response based on the incoming result to the user. If an answer has been identified it
     * is sent to the user. Alternatively, if no answer has been identified or the user has indicated 'no match' on an
     * active learning card, then an appropriate message is sent to the user.
     *
     * @param {WaterfallStepContext} step the waterfall step context
     * @returns {Promise<DialogTurnResult>} a promise resolving to the dialog turn result
     **/
    displayQnAResult(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const reply = step.context.activity.text;
            if (reply === dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                yield step.context.sendActivity(activity !== null && activity !== void 0 ? activity : this.defaultCardNoMatchResponse);
                return step.endDialog();
            }
            const previousQnaId = step.activeDialog.state[this.previousQnAId];
            if (previousQnaId > 0) {
                return _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
            }
            const response = step.result;
            if ((response === null || response === void 0 ? void 0 : response.length) > 0) {
                yield step.context.sendActivity(response[0].answer);
            }
            else {
                const activity = dialogOptions.qnaDialogResponseOptions.noAnswer;
                yield step.context.sendActivity(activity || this.defaultNoAnswer);
            }
            return step.endDialog(step.result);
        });
    }
    resetOptions(dc, dialogOptions) {
        var _a, _b;
        // Resetting context and QnAId
        dialogOptions.qnaMakerOptions.qnaId = 0;
        dialogOptions.qnaMakerOptions.context = { previousQnAId: 0, previousUserQuery: '' };
        // Check if previous context is present, if yes then put it with the query
        // Check for id if query is present in reverse index.
        const previousContextData = (_a = dc.activeDialog.state[this.qnAContextData]) !== null && _a !== void 0 ? _a : {};
        const previousQnAId = (_b = dc.activeDialog.state[this.previousQnAId]) !== null && _b !== void 0 ? _b : 0;
        if (previousQnAId > 0) {
            dialogOptions.qnaMakerOptions.context = {
                previousQnAId,
                previousUserQuery: '',
            };
            const currentQnAId = previousContextData[dc.context.activity.text];
            if (currentQnAId) {
                dialogOptions.qnaMakerOptions.qnaId = currentQnAId;
            }
        }
    }
    // Queries the knowledgebase and either passes result to the next step or constructs and displays an active learning card
    // if active learning is enabled and multiple score close answers are returned.
    callGenerateAnswer(step) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            // clear suggestedQuestions between turns.
            step.state.deleteValue('this.suggestedQuestions');
            const dialogOptions = step.activeDialog.state[this.options];
            this.resetOptions(step, dialogOptions);
            step.values[this.currentQuery] = step.context.activity.text;
            const previousContextData = step.activeDialog.state[this.qnAContextData] || {};
            let previousQnAId = step.activeDialog.state[this.previousQnAId] || 0;
            if (previousQnAId > 0) {
                dialogOptions.qnaMakerOptions.context = { previousQnAId, previousUserQuery: '' };
                if (previousContextData[step.context.activity.text]) {
                    dialogOptions.qnaMakerOptions.qnaId = previousContextData[step.context.activity.text];
                }
            }
            const qna = yield this.getQnAMakerClient(step);
            const response = yield qna.getAnswersRaw(step.context, dialogOptions.qnaMakerOptions);
            const qnaResponse = {
                activeLearningEnabled: response.activeLearningEnabled,
                answers: response.answers,
            };
            previousQnAId = -1;
            step.activeDialog.state[this.previousQnAId] = previousQnAId;
            const isActiveLearningEnabled = qnaResponse.activeLearningEnabled;
            step.values[this.qnAData] = response.answers;
            if (qnaResponse.answers.length > 0 &&
                qnaResponse.answers[0].score <= qnamaker_utils_1.ActiveLearningUtils.MaximumScoreForLowScoreVariation / 100) {
                qnaResponse.answers = qna.getLowScoreVariation(qnaResponse.answers);
                if (isActiveLearningEnabled && ((_a = qnaResponse.answers) === null || _a === void 0 ? void 0 : _a.length) > 1) {
                    const suggestedQuestions = qnaResponse.answers.map((answer) => answer.questions[0]);
                    const message = (_c = (_b = this.suggestionsActivityFactory) === null || _b === void 0 ? void 0 : _b.call(this, suggestedQuestions, dialogOptions.qnaDialogResponseOptions.cardNoMatchText)) !== null && _c !== void 0 ? _c : qnaCardBuilder_1.QnACardBuilder.getSuggestionsCard(suggestedQuestions, dialogOptions.qnaDialogResponseOptions.activeLearningCardTitle, dialogOptions.qnaDialogResponseOptions.cardNoMatchText);
                    botbuilder_stdlib_1.assert.object(message, ['suggestionsActivity']);
                    yield step.context.sendActivity(message);
                    step.activeDialog.state[this.options] = dialogOptions;
                    step.state.setValue('this.suggestedQuestions', suggestedQuestions);
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            const result = [];
            if (((_d = response.answers) === null || _d === void 0 ? void 0 : _d.length) > 0) {
                result.push(response.answers[0]);
            }
            step.values[this.qnAData] = result;
            step.activeDialog.state[this.options] = dialogOptions;
            return step.next(result);
        });
    }
    // If active learning options were displayed in the previous step and the user has selected an option other
    // than 'no match' then the training API is called, passing the user's chosen question back to the knowledgebase.
    // If no active learning options were displayed in the previous step, the incoming result is immediately passed to the next step.
    callTrain(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const trainResponses = step.values[this.qnAData];
            const currentQuery = step.values[this.currentQuery];
            const reply = step.context.activity.text;
            if ((trainResponses === null || trainResponses === void 0 ? void 0 : trainResponses.length) > 1) {
                const qnaResult = trainResponses.filter((r) => r.questions[0] === reply);
                if ((qnaResult === null || qnaResult === void 0 ? void 0 : qnaResult.length) > 0) {
                    const results = [];
                    results.push(qnaResult[0]);
                    step.values[this.qnAData] = results;
                    const records = [];
                    records.push({
                        userId: step.context.activity.id,
                        userQuestion: currentQuery,
                        qnaId: qnaResult[0].id.toString(),
                    });
                    const feedbackRecords = { feedbackRecords: records };
                    const qnaClient = yield this.getQnAMakerClient(step);
                    yield qnaClient.callTrain(feedbackRecords);
                    return step.next(qnaResult);
                }
                else if (reply === dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                    const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                    yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                    return step.endDialog();
                }
                else {
                    return _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
                }
            }
            return step.next(step.result);
        });
    }
    // If multi turn prompts are included with the answer returned from the knowledgebase, this step constructs
    // and sends an activity with a hero card displaying the answer and the multi turn prompt options.
    // If no multi turn prompts exist then the result incoming result is passed to the next step.
    checkForMultiTurnPrompt(step) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const response = step.result;
            if ((response === null || response === void 0 ? void 0 : response.length) > 0) {
                const answer = response[0];
                if (((_b = (_a = answer === null || answer === void 0 ? void 0 : answer.context) === null || _a === void 0 ? void 0 : _a.prompts) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                    const previousContextData = {};
                    answer.context.prompts.forEach((prompt) => {
                        previousContextData[prompt.displayText] = prompt.qnaId;
                    });
                    step.activeDialog.state[this.qnAContextData] = previousContextData;
                    step.activeDialog.state[this.previousQnAId] = answer.id;
                    step.activeDialog.state[this.options] = dialogOptions;
                    const message = qnaCardBuilder_1.QnACardBuilder.getQnAPromptsCard(answer);
                    yield step.context.sendActivity(message);
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            return step.next(step.result);
        });
    }
    // Gets unmodified v5 API hostName or constructs v4 API hostName
    //
    // Example of a complete v5 API endpoint: "https://qnamaker-acom.azure.com/qnamaker/v5.0"
    //
    // Template literal to construct v4 API endpoint: `https://${ this.hostName }.azurewebsites.net/qnamaker`
    getHost(dc) {
        let host = this.hostname.getValue(dc.state);
        // Return the memoized host, but allow it to change at runtime.
        if (this.normalizedHost && this.normalizedHost.includes(host)) {
            return this.normalizedHost;
        }
        // Handle no protocol.
        if (!/^https?:\/\//.test(host)) {
            host = 'https://' + host;
        }
        // Handle no domain.
        if (!host.includes('.')) {
            host = host + '.azurewebsites.net';
        }
        // Handle no pathname, only for azurewebsites.net domains.
        if (!host.includes('/qnamaker') && host.includes('azurewebsites.net')) {
            host = host + '/qnamaker';
        }
        // Memoize the host.
        this.normalizedHost = host;
        return host;
    }
}
exports.QnAMakerDialog = QnAMakerDialog;
QnAMakerDialog.$kind = 'Microsoft.QnAMakerDialog';
//# sourceMappingURL=qnaMakerDialog.js.map