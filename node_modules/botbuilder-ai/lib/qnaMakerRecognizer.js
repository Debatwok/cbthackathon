"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QnAMakerRecognizer = void 0;
const adaptive_expressions_1 = require("adaptive-expressions");
const omit_1 = __importDefault(require("lodash/omit"));
const botbuilder_core_1 = require("botbuilder-core");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const qnaMaker_1 = require("./qnaMaker");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const intentPrefix = 'intent=';
/**
 * A recognizer which uses QnAMaker KB to recognize intents.
 */
class QnAMakerRecognizer extends botbuilder_dialogs_1.Recognizer {
    /**
     * Initializes a new instance of `QnAMakerRecognizer`.
     *
     * @param {string} hostname Hostname of QnAMaker KB.
     * @param {string} knowledgeBaseId Id of QnAMaker KB.
     * @param {string} endpointKey Endpoint key of QnAMaker KB.
     */
    constructor(hostname, knowledgeBaseId, endpointKey) {
        super();
        /**
         * Number of results you want.
         */
        this.top = new adaptive_expressions_1.IntExpression(3);
        /**
         * Threshold for the results.
         */
        this.threshold = new adaptive_expressions_1.NumberExpression(0.3);
        /**
         * Desired RankerType.
         */
        this.rankerType = new adaptive_expressions_1.StringExpression(qnamaker_interfaces_1.RankerTypes.default);
        /**
         * Whether to include the dialog name metadata for QnA context.
         */
        this.includeDialogNameInMetadata = new adaptive_expressions_1.BoolExpression(true);
        /**
         * An expression to evaluate to set QnAId parameter.
         */
        this.qnaId = new adaptive_expressions_1.IntExpression(0);
        /**
         * The flag to indicate if personal information should be logged in telemetry.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.runtimeSettings.telemetry.logPersonalInformation');
        if (hostname) {
            this.hostname = new adaptive_expressions_1.StringExpression(hostname);
        }
        if (knowledgeBaseId) {
            this.knowledgeBaseId = new adaptive_expressions_1.StringExpression(knowledgeBaseId);
        }
        if (endpointKey) {
            this.endpointKey = new adaptive_expressions_1.StringExpression(endpointKey);
        }
    }
    getConverter(property) {
        switch (property) {
            case 'knowledgeBaseId':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'hostname':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'top':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'threshold':
                return new adaptive_expressions_1.NumberExpressionConverter();
            case 'rankerType':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'includeDialogNameInMetadata':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'metadata':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'context':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            case 'qnaId':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Gets results of the call to QnA maker KB.
     *
     * @param {DialogContext} dc Context object containing information for a single turn of coversation with a user.
     * @param {Activity} activity The incoming activity received from the user. The text value is used as the query to QnA Maker.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry.
     * @param {object} telemetryMetrics Additional metrics to be logged to telemetry.
     * @returns {Promise<RecognizerResult>} A promise resolving to the recognizer result
     */
    recognize(dc, activity, telemetryProperties, telemetryMetrics) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            // identify matched intents
            const recognizerResult = {
                text: activity.text,
                intents: {},
                entities: {},
            };
            if (!activity.text) {
                recognizerResult.intents['None'] = { score: 1 };
                return recognizerResult;
            }
            const filters = [];
            if ((_a = this.includeDialogNameInMetadata) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) {
                const metadata = {
                    name: 'dialogName',
                    value: (_b = dc.activeDialog) === null || _b === void 0 ? void 0 : _b.id,
                };
                filters.push(metadata);
            }
            // if there is $qna.metadata set add to filters
            const externalMetadata = (_c = this.metadata) === null || _c === void 0 ? void 0 : _c.getValue(dc.state);
            if (externalMetadata) {
                filters.push(...externalMetadata);
            }
            // calling QnAMaker to get response
            const qnaMaker = this.getQnAMaker(dc);
            const qnaMakerOptions = {
                context: (_d = this.context) === null || _d === void 0 ? void 0 : _d.getValue(dc.state),
                scoreThreshold: (_e = this.threshold) === null || _e === void 0 ? void 0 : _e.getValue(dc.state),
                strictFilters: filters,
                top: (_f = this.top) === null || _f === void 0 ? void 0 : _f.getValue(dc.state),
                qnaId: (_g = this.qnaId) === null || _g === void 0 ? void 0 : _g.getValue(dc.state),
                rankerType: (_h = this.rankerType) === null || _h === void 0 ? void 0 : _h.getValue(dc.state),
                isTest: this.isTest,
                strictFiltersJoinOperator: this.strictFiltersJoinOperator,
            };
            const answers = yield qnaMaker.getAnswers(dc.context, qnaMakerOptions);
            if ((answers === null || answers === void 0 ? void 0 : answers.length) > 0) {
                let topAnswer;
                for (let i = 0; i < answers.length; i++) {
                    const answer = answers[i];
                    if (!topAnswer || answer.score > topAnswer.score) {
                        topAnswer = answer;
                    }
                }
                if (topAnswer.answer.trim().toLowerCase().startsWith(intentPrefix)) {
                    recognizerResult.intents[topAnswer.answer.trim().substr(intentPrefix.length).trim()] = {
                        score: topAnswer.score,
                    };
                }
                else {
                    recognizerResult.intents[QnAMakerRecognizer.qnaMatchIntent] = { score: topAnswer.score };
                }
                recognizerResult.entities['answer'] = [topAnswer.answer];
                recognizerResult.entities['$instance'] = {
                    answer: [
                        Object.assign(topAnswer, {
                            startIndex: 0,
                            endIndex: activity.text.length,
                        }),
                    ],
                };
                recognizerResult['answers'] = answers;
            }
            else {
                recognizerResult.intents['None'] = { score: 1 };
            }
            this.trackRecognizerResult(dc, 'QnAMakerRecognizerResult', this.fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dc), telemetryMetrics);
            return recognizerResult;
        });
    }
    /**
     * Gets an instance of `QnAMaker`.
     *
     * @deprecated Instead, favor using [QnAMakerRecognizer.getQnAMakerClient()](#getQnAMakerClient) to get instance of QnAMakerClient.
     * @param {DialogContext} dc The dialog context used to access state.
     * @returns {QnAMaker} A qna maker instance
     */
    getQnAMaker(dc) {
        const options = [
            [this.endpointKey, 'endpointKey'],
            [this.hostname, 'host'],
            [this.knowledgeBaseId, 'knowledgeBaseId'],
        ];
        const [endpointKey, host, knowledgeBaseId] = options.map(([expression, key]) => {
            var _a;
            const { value, error } = (_a = expression === null || expression === void 0 ? void 0 : expression.tryGetValue(dc.state)) !== null && _a !== void 0 ? _a : {};
            if (!value || error) {
                throw new Error(`Unable to get a value for ${key} from state. ${error}`);
            }
            return value;
        });
        const endpoint = { endpointKey, host, knowledgeBaseId };
        const logPersonalInfo = this.getLogPersonalInformation(dc);
        return new qnaMaker_1.QnAMaker(endpoint, {}, this.telemetryClient, logPersonalInfo);
    }
    /**
     * Gets an instance of [QnAMakerClient](xref:botbuilder-ai.QnAMakerClient)
     *
     * @param {DialogContext} dc The dialog context used to access state.
     * @returns {QnAMakerClient} An instance of QnAMakerClient.
     */
    getQnAMakerClient(dc) {
        var _a, _b;
        const qnaClient = (_b = (_a = dc.context) === null || _a === void 0 ? void 0 : _a.turnState) === null || _b === void 0 ? void 0 : _b.get(qnaMaker_1.QnAMakerClientKey);
        if (qnaClient) {
            return qnaClient;
        }
        const options = [
            [this.endpointKey, 'endpointKey'],
            [this.hostname, 'host'],
            [this.knowledgeBaseId, 'knowledgeBaseId'],
        ];
        const [endpointKey, host, knowledgeBaseId] = options.map(([expression, key]) => {
            var _a;
            const { value, error } = (_a = expression === null || expression === void 0 ? void 0 : expression.tryGetValue(dc.state)) !== null && _a !== void 0 ? _a : {};
            if (!value || error) {
                throw new Error(`Unable to get a value for ${key} from state. ${error}`);
            }
            return value;
        });
        const endpoint = { endpointKey, host, knowledgeBaseId };
        const logPersonalInfo = this.getLogPersonalInformation(dc);
        return new qnaMaker_1.QnAMaker(endpoint, {}, this.telemetryClient, logPersonalInfo);
    }
    /**
     * Uses the recognizer result to create a collection of properties to be included when tracking the result in telemetry.
     *
     * @param {RecognizerResult} recognizerResult The result of the intent recognized by the recognizer.
     * @param {Record<string, string>} telemetryProperties A list of properties created using the RecognizerResult.
     * @param {DialogContext} dc The DialogContext.
     * @returns {Record<string, string>} A collection of properties that can be used when calling the trackEvent method on the telemetry client.
     */
    fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dc) {
        if (!dc) {
            throw new Error('DialogContext needed for state in AdaptiveRecognizer.fillRecognizerResultTelemetryProperties method.');
        }
        const { intent, score } = botbuilder_core_1.getTopScoringIntent(recognizerResult);
        const intentsCount = Object.entries(recognizerResult.intents).length;
        const properties = {
            TopIntent: intentsCount > 0 ? intent : undefined,
            TopIntentScore: intentsCount > 0 ? score.toString() : undefined,
            Intents: intentsCount > 0 ? JSON.stringify(recognizerResult.intents) : undefined,
            Entities: recognizerResult.entities ? JSON.stringify(recognizerResult.entities) : undefined,
            AdditionalProperties: JSON.stringify(omit_1.default(recognizerResult, ['text', 'alteredText', 'intents', 'entities'])),
        };
        const logPersonalInformation = this.getLogPersonalInformation(dc);
        if (logPersonalInformation) {
            properties['Text'] = recognizerResult.text;
            properties['AlteredText'] = recognizerResult.alteredText;
        }
        // Additional Properties can override "stock" properties.
        if (telemetryProperties) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
    getLogPersonalInformation(dc) {
        return this.logPersonalInformation instanceof adaptive_expressions_1.BoolExpression
            ? this.logPersonalInformation.getValue(dc.state)
            : this.logPersonalInformation;
    }
}
exports.QnAMakerRecognizer = QnAMakerRecognizer;
QnAMakerRecognizer.$kind = 'Microsoft.QnAMakerRecognizer';
QnAMakerRecognizer.qnaMatchIntent = 'QnAMatch';
//# sourceMappingURL=qnaMakerRecognizer.js.map