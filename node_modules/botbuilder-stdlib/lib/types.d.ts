import { NewableError } from './assertExt';
export declare type Nil = null | undefined;
export declare type Maybe<T> = T | Nil;
export declare type Newable<T, A extends unknown[] = unknown[]> = new (...args: A) => T;
export declare type Extends<T> = Function & {
    prototype: T;
};
export declare type Dictionary<V = unknown, K extends string | number = string | number> = Record<K, V>;
export declare type Test<T> = (val: unknown) => val is T;
export declare type Assertion<T> = (val: unknown, path: string[]) => asserts val is T;
/**
 * An error that indicates that the source of the error was an undefined value
 */
export declare class UndefinedError extends Error {
}
/**
 * Asserts `cond` to the typescript compiler
 *
 * @param {any} cond a condition to assert
 * @param {string[]} path the accumulated path for the assertion
 * @param {string} message an error message to use
 * @param {NewableError} errorCtor an optional error constructor
 */
declare function condition(cond: unknown, path: string[], message: string, errorCtor?: NewableError): asserts cond;
/**
 * Construct an assertion function
 *
 * @template T the type to assert
 * @param {string} typeName the name of type `T`
 * @param {Test<T>} test a method to test if an unknown value is of type `T`
 * @param {boolean} acceptNil true if null or undefined values are acceptable
 * @returns {Assertion<T>} an assertion that asserts an unknown value is of type `T`
 */
declare function makeAssertion<T>(typeName: string, test: Test<T>, acceptNil?: boolean): Assertion<T>;
/**
 * Constructs a type assertion that is enforced if the value is not null or undefined
 *
 * @template T the type to assert
 * @param {Assertion<T>} assertion the assertion
 * @returns {Assertion<Maybe<T>>} an assertion that asserts an unknown value is of type `T` or `Nil`
 */
declare function makeMaybeAssertion<T>(assertion: Assertion<T>): Assertion<Maybe<T>>;
/**
 * Takes an assertion for type `T` and returns an assertion for type `Partial<T>`. The implementation
 * expects that the assertion throws `UndefinedError` if an expected value is undefined. All the assertions
 * exported by this package satisfy that requirement.
 *
 * @template T a type extending from `Dictionary`
 * @param {Assertion<T>} assertion an assertion that asserts an unknown value is of type `T`
 * @returns {Assertion<Partial<T>>} an assertion that asserts an unknown value is of type `Partial<T>`
 */
declare function makePartialAssertion<T extends Dictionary>(assertion: Assertion<T>): Assertion<Partial<T>>;
/**
 * Test if `val` is of type `any`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `any`
 */
declare function isAny(val: unknown): val is any;
/**
 * Assert that `val` is of type `any`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function any(val: unknown, path: string[]): asserts val is any;
/**
 * Assert that `val` is of type `any`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeAny(val: unknown, path: string[]): asserts val is Maybe<any>;
/**
 * Test if `val` is of type `array`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `array`
 */
declare function isArray(val: unknown): val is unknown[];
/**
 * Assert that `val` is of type `array`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function array(val: unknown, path: string[]): asserts val is unknown[];
/**
 * Assert that `val` is of type `array`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeArray(val: unknown, path: string[]): asserts val is Maybe<unknown[]>;
/**
 * Test if `val` is of type `boolean`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `boolean`
 */
declare function isBoolean(val: unknown): val is boolean;
/**
 * Assert that `val` is of type `boolean`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function boolean(val: unknown, path: string[]): asserts val is boolean;
/**
 * Assert that `val` is of type `boolean`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeBoolean(val: unknown, path: string[]): asserts val is Maybe<boolean>;
/**
 * Test if `val` is of type `Date`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `Date`
 */
declare function isDate(val: unknown): val is Date;
/**
 * Assert that `val` is of type `Date`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function date(val: unknown, path: string[]): asserts val is Date;
/**
 * Assert that `val` is of type `Date`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeDate(val: unknown, path: string[]): asserts val is Maybe<Date>;
/**
 * Test if `val` is of type `Dictionary`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `Dictionary`
 */
declare function isDictionary(val: unknown): val is Dictionary;
/**
 * Assert that `val` is of type `Dictionary`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function dictionary(val: unknown, path: string[]): asserts val is Dictionary;
/**
 * Assert that `val` is of type `Dictionary`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeDictionary(val: unknown, path: string[]): asserts val is Maybe<Dictionary>;
/**
 * Test if `val` is of type `Error`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `Error`
 */
declare function isError(val: unknown): val is Error;
/**
 * Assert that `val` is of type `Error`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function error(val: unknown, path: string[]): asserts val is Error;
/**
 * Test if `val` is of type `TypeError`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `TypeError`
 */
declare function isTypeError(val: unknown): val is TypeError;
/**
 * Assert that `val` is of type `TypeError`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function typeError(val: unknown, path: string[]): asserts val is TypeError;
/**
 * Test if `val` is of type `UndefinedError`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `UndefinedError`
 */
declare function isUndefinedError(val: unknown): val is UndefinedError;
/**
 * Assert that `val` is of type `UndefinedError`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function undefinedError(val: unknown, path: string[]): asserts val is UndefinedError;
export declare type Func<T extends unknown[] = unknown[], R = unknown> = (...args: T) => R;
/**
 * Test if `val` is of type `Func`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `Func`
 */
declare function isFunc(val: unknown): val is Func;
/**
 * Assert that `val` is of type `Func`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function func(val: unknown, path: string[]): asserts val is Func;
/**
 * Assert that `val` is of type `Func`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeFunc(val: unknown, path: string[]): asserts val is Maybe<Func>;
/**
 * Test if `val` is of type `Nil`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `Func`
 */
declare function isNil(val: unknown): val is Nil;
/**
 * Assert that `val` is of type `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function nil(val: unknown, path: string[]): asserts val is Nil;
/**
 * Test if `val` is of type `string`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `string`
 */
declare function isString(val: unknown): val is string;
/**
 * Test if `val` is of type `string` with zero length or `Nil`.
 *
 * @remarks
 * Implementation of string.IsNullOrEmpty(): https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=netcore-3.1
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of `string` with zero length or `Nil`
 */
declare function isStringNullOrEmpty(val: unknown): val is Maybe<string>;
/**
 * Assert that `val` is of type `string`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function string(val: unknown, path: string[]): asserts val is string;
/**
 * Assert that `val` is of type `string`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeString(val: unknown, path: string[]): asserts val is Maybe<string>;
/**
 * Test if `val` is of type `number`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `number`
 */
declare function isNumber(val: unknown): val is number;
/**
 * Assert that `val` is of type `number`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function number(val: unknown, path: string[]): asserts val is number;
/**
 * Assert that `val` is of type `number`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeNumber(val: unknown, path: string[]): asserts val is Maybe<number>;
/**
 * Test if `val` is of type `object`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `object`
 */
declare function isObject(val: unknown): val is object;
/**
 * Assert that `val` is of type `object`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function object(val: unknown, path: string[]): asserts val is object;
/**
 * Assert that `val` is of type `object`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeObject(val: unknown, path: string[]): asserts val is Maybe<object>;
/**
 * Test if `val` is of type `unknown`.
 *
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `unknown`
 */
declare function isUnknown(val: unknown): val is unknown;
/**
 * Assert that `val` is of type `unknown`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function unknown(val: unknown, path: string[]): asserts val is unknown;
/**
 * Assert that `val` is of type `unknown`, or `Nil`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function maybeUnknown(val: unknown, path: string[]): asserts val is Maybe<unknown>;
/**
 * Make a type test function out of an assertion
 *
 * @template T the type to test
 * @param {Assertion<T>} assertion an assertion
 * @returns {Test<T>} a type test that returns true if an unknown value is of type `T`
 */
declare function makeTest<T>(assertion: Assertion<T>): Test<T>;
/**
 * **UNSAFE**
 * Test if `val` is of type `object`.
 * This test does not actually verify that `val` is of type `T`. It is useful as the first
 * line in a nested assertion so that remaining assertion calls can leverage helpful intellisense.
 * This method is only exported under the `unsafe` keyword as a constant reminder of this fact.
 *
 * @template T the type to cast `val` to, should extend `Dictionary<unknown>`, i.e. be itself an object
 * @param {any} val value to test
 * @returns {boolean} true if `val` is of type `object`
 */
declare function isObjectAs<T>(val: unknown): val is T;
export declare const tests: {
    isAny: typeof isAny;
    isArray: typeof isArray;
    isBoolean: typeof isBoolean;
    isDate: typeof isDate;
    isDictionary: typeof isDictionary;
    isFunc: typeof isFunc;
    isNil: typeof isNil;
    isNumber: typeof isNumber;
    isObject: typeof isObject;
    isString: typeof isString;
    isStringNullOrEmpty: typeof isStringNullOrEmpty;
    isUnknown: typeof isUnknown;
    isError: typeof isError;
    isTypeError: typeof isTypeError;
    isUndefinedError: typeof isUndefinedError;
    fromAssertion: typeof makeTest;
    toAssertion: typeof makeAssertion;
    unsafe: {
        isObjectAs: typeof isObjectAs;
    };
};
/**
 * Construct an assertion that an unknown value is an array with items of type `T`
 *
 * @template T the item type
 * @param {Assertion<T>} assertion the assertion
 * @returns {Assertion<Array<T>>} an assertion that asserts an unknown value is an array with items of type `T`
 */
declare function arrayOf<T>(assertion: Assertion<T>): Assertion<Array<T>>;
/**
 * Assert that `val` is of type `string[]`.
 *
 * @param {any} val value to assert
 * @param {string[]} path path to val (useful for nested assertions)
 */
declare function arrayOfString(val: unknown, path: string[]): asserts val is string[];
/**
 * Construct an assertion that an unknown value is an array with items of type `T`, or `Nil`
 *
 * @template T the item type
 * @param {Assertion<T>} assertion the assertion
 * @returns {Assertion<Maybe<Array<T>>>} an assertion that asserts an unknown value is an array with
 * items of type `T`, or `Nil`
 */
declare function maybeArrayOf<T>(assertion: Assertion<T>): Assertion<Maybe<Array<T>>>;
/**
 * Construct an assertion that an unknown value is an instance of type `T`
 *
 * @template T the instance type
 * @param {string} typeName the name of type `T`
 * @param {Newable<T> | Extends<T>} ctor a constructor reference for type `T`
 * @returns {Assertion<T>} an assertion that asserts an unknown value is an instance of type `T`
 */
declare function instanceOf<T>(typeName: string, ctor: Newable<T> | Extends<T>): Assertion<T>;
/**
 * Construct an assertion that an unknown value is an instance of type `T`, or `Nil`
 *
 * @template T the instance type
 * @param {string} typeName the name of type `T`
 * @param {Newable<T> | Extends<T>} ctor a constructor reference for type `T`
 * @returns {Assertion<Maybe<T>>} an assertion that asserts an unknown value is an instance of type `T`, or `Nil`
 */
declare function maybeInstanceOf<T>(typeName: string, ctor: Newable<T> | Extends<T>): Assertion<Maybe<T>>;
/**
 * Construct an assertion that an unknown value is of type `T`, likely a union type
 *
 * @template T the type, likely a union of other types
 * @param {Array<Test<T>>} tests a set of tests for type `T`
 * @returns {Assertion<T>} an assertion that asserts an unknown value is of type `T`
 */
declare function oneOf<T>(...tests: Array<Test<T>>): Assertion<T>;
/**
 * Construct an assertion that an unknown value is of type `T`, likely a union type, or `Nil`
 *
 * @template T the type, likely a union of other types
 * @param {Array<Test<T>>} tests a set of tests for type `T`
 * @returns {Assertion<Maybe<T>>} an assertion that asserts an unknown value is of type `T`, or `Nil`
 */
declare function maybeOneOf<T>(...tests: Array<Test<T>>): Assertion<Maybe<T>>;
/**
 * **UNSAFE**
 * This assertion does not actually verify that `val` is of type `T`. It is useful as the first
 * line in a nested assertion so that remaining assertion calls can leverage helpful intellisense.
 * This method is only exported under the `unsafe` keyword as a constant reminder of this fact.
 *
 * @template T the type to cast `val` to, should extend `Dictionary<unknown>`, i.e. be itself an object
 * @param {any} val the unknown value
 * @param {string[]} path the accumulated assertion path
 */
declare function castObjectAs<T>(val: unknown, path: string[]): asserts val is T;
export declare const assert: {
    condition: typeof condition;
    any: typeof any;
    maybeAny: typeof maybeAny;
    array: typeof array;
    maybeArray: typeof maybeArray;
    boolean: typeof boolean;
    maybeBoolean: typeof maybeBoolean;
    date: typeof date;
    maybeDate: typeof maybeDate;
    dictionary: typeof dictionary;
    maybeDictionary: typeof maybeDictionary;
    error: typeof error;
    undefinedError: typeof undefinedError;
    typeError: typeof typeError;
    func: typeof func;
    maybeFunc: typeof maybeFunc;
    nil: typeof nil;
    number: typeof number;
    maybeNumber: typeof maybeNumber;
    object: typeof object;
    maybeObject: typeof maybeObject;
    string: typeof string;
    maybeString: typeof maybeString;
    unknown: typeof unknown;
    maybeUnknown: typeof maybeUnknown;
    arrayOf: typeof arrayOf;
    maybeArrayOf: typeof maybeArrayOf;
    arrayOfString: typeof arrayOfString;
    instanceOf: typeof instanceOf;
    maybeInstanceOf: typeof maybeInstanceOf;
    oneOf: typeof oneOf;
    maybeOneOf: typeof maybeOneOf;
    fromTest: typeof makeAssertion;
    makeMaybe: typeof makeMaybeAssertion;
    makePartial: typeof makePartialAssertion;
    toTest: typeof makeTest;
    unsafe: {
        castObjectAs: typeof castObjectAs;
    };
};
export {};
//# sourceMappingURL=types.d.ts.map