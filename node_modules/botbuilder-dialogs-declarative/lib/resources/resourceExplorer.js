"use strict";
/**
 * @module botbuilder-dialogs-declarative
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceExplorer = void 0;
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const path_1 = require("path");
const events_1 = require("events");
const resourceProvider_1 = require("./resourceProvider");
const folderResourceProvider_1 = require("./folderResourceProvider");
const pathUtil_1 = require("../pathUtil");
const defaultLoader_1 = require("../defaultLoader");
/**
 * Class which gives standard access to content resources.
 */
class ResourceExplorer {
    constructor(providersOrOptions = []) {
        var _a;
        this._kindToType = new Map();
        this._kindDeserializer = new Map();
        this._eventEmitter = new events_1.EventEmitter();
        this._cache = new Map();
        this._typesLoaded = false;
        /**
         * Gets resource type id extensions managed by resource explorer.
         */
        this.resourceTypes = new Set(['dialog', 'lu', 'lg', 'qna', 'schema', 'json']);
        if (Array.isArray(providersOrOptions)) {
            const providers = providersOrOptions;
            this.resourceProviders = providers;
        }
        else {
            const options = providersOrOptions;
            this.resourceProviders = (_a = options.providers) !== null && _a !== void 0 ? _a : [];
            if (options.declarativeTypes) {
                this._declarativeTypes = options.declarativeTypes;
            }
        }
    }
    /**
     * Event which fires when a resource is changed.
     */
    set changed(callback) {
        this._eventEmitter.on(resourceProvider_1.ResourceChangeEvent.added, (resources) => {
            callback(resourceProvider_1.ResourceChangeEvent.added, resources);
        });
        this._eventEmitter.on(resourceProvider_1.ResourceChangeEvent.changed, (resources) => {
            callback(resourceProvider_1.ResourceChangeEvent.changed, resources);
        });
        this._eventEmitter.on(resourceProvider_1.ResourceChangeEvent.removed, (resources) => {
            callback(resourceProvider_1.ResourceChangeEvent.removed, resources);
        });
    }
    /**
     * Add a resource type to resource type set.
     *
     * @param {string} type Resource type.
     */
    addResourceType(type) {
        type = type.toLowerCase().replace(/^\./, '');
        if (!this.resourceTypes.has(type)) {
            this.resourceTypes.add(type);
            this.refresh();
        }
    }
    /**
     * Reload any cached data.
     */
    refresh() {
        this.resourceProviders.forEach((resourceProvider) => resourceProvider.refresh());
    }
    /**
     * Add a resource provider to the resources managed by resource explorer.
     *
     * @param {ResourceProvider} resourceProvider Resource provider to be added.
     * @returns {ResourceExplorer} Resource explorer so that you can fluently call multiple methods on the resource explorer.
     */
    addResourceProvider(resourceProvider) {
        if (this.resourceProviders.some((r) => r.id === resourceProvider.id)) {
            throw Error(`${resourceProvider.id} has already been added as a resource`);
        }
        resourceProvider.changed = this.onChanged.bind(this);
        this.resourceProviders.push(resourceProvider);
        return this;
    }
    /**
     * Add a folder resource.
     *
     * @param {string}  folder Folder to be included as a resource.
     * @param {boolean} includeSubFolders Whether to include subfolders.
     * @param {boolean} monitorChanges Whether to track changes.
     * @returns {ResourceExplorer} Resource explorer so that you can fluently call multiple methods on the resource explorer.
     */
    addFolder(folder, includeSubFolders = true, monitorChanges = true) {
        this.addResourceProvider(new folderResourceProvider_1.FolderResourceProvider(this, folder, includeSubFolders, monitorChanges));
        return this;
    }
    /**
     * Add folder resources.
     *
     * @param {string} folder Collection of folders to be included as resources.
     * @param {string[]} ignoreFolders Imediate subfolders to ignore.
     * @param {boolean} monitorChanges Whether to track changes.
     * @returns {ResourceExplorer} Resource explorer so that you can fluently call multiple methods on the resource explorer.
     */
    addFolders(folder, ignoreFolders, monitorChanges = true) {
        if (ignoreFolders) {
            folder = path_1.normalize(folder);
            this.addFolder(folder, false, monitorChanges);
            const ignoreFoldersSet = new Set(ignoreFolders.map((p) => path_1.join(folder, p)));
            const subFolders = pathUtil_1.PathUtil.getDirectories(folder);
            for (let i = 0; i < subFolders.length; i++) {
                const subFolder = subFolders[i];
                if (!ignoreFoldersSet.has(subFolder)) {
                    this.addFolder(subFolder, true, monitorChanges);
                }
            }
        }
        else {
            this.addFolder(folder, true, monitorChanges);
        }
        return this;
    }
    /**
     * Get resources of a given type extension.
     *
     * @param {string} fileExtension File extension filter.
     * @returns {Resource[]} The resources.
     */
    getResources(fileExtension) {
        const resources = [];
        for (const rp of this.resourceProviders) {
            for (const rpResources of rp.getResources(fileExtension)) {
                resources.push(rpResources);
            }
        }
        return resources;
    }
    /**
     * Gets resource by id.
     *
     * @param {string} id Resource id.
     * @returns {Resource} The resource, or undefined if not found.
     */
    getResource(id) {
        for (const rp of this.resourceProviders) {
            const resource = rp.getResource(id);
            if (resource) {
                return resource;
            }
        }
        return undefined;
    }
    /**
     * Register a declarative type with the resource loader system.
     *
     * @template T The type of object.
     * @param {string} kind The $kind name to map to this type.
     * @param {Newable<T>} type Type of object to create.
     * @param {CustomDeserializer}  loader Optional custom deserializer.
     * @returns {ResourceExplorer} Resource explorer for fluent style multiple calls.
     */
    registerType(kind, type, loader) {
        this.registerComponentTypes();
        this.registerTypeInternal(kind, type, loader);
        return this;
    }
    /**
     * Build type for given $kind from configuration.
     *
     * @template T Type of object.
     * @template C Type of configuration
     * @param {string} kind $kind.
     * @param {C} config Source configuration object.
     * @returns {T} Instantiated object.
     */
    buildType(kind, config) {
        this.registerComponentTypes();
        const type = this._kindToType.get(kind);
        if (!type) {
            throw new Error(`Type ${kind} not registered.`);
        }
        const loader = this._kindDeserializer.get(kind);
        return loader.load(config, type);
    }
    loadType(resourceOrId) {
        this.registerComponentTypes();
        const resource = typeof resourceOrId === 'string' ? this.getResource(resourceOrId) : resourceOrId;
        if (!resource) {
            throw new Error(`Resource ${typeof resourceOrId === 'string' ? resourceOrId : resourceOrId.id} not found.`);
        }
        if (this._cache.has(resource.id)) {
            return this._cache.get(resource.id);
        }
        const json = resource.readText();
        const config = JSON.parse(json);
        const result = this.preload(config.$kind, resource.id);
        Object.assign(result, JSON.parse(json, (_key, value) => {
            if (typeof value !== 'object' || value === null) {
                return value;
            }
            if (Array.isArray(value)) {
                return value;
            }
            const kind = value['$kind'];
            if (!kind) {
                return value;
            }
            return this.load(value);
        }));
        if (result instanceof botbuilder_dialogs_1.Dialog && !config['id']) {
            // If there is no id for the dialog, then the resource id would be used as dialog id.
            result.id = resource.id;
        }
        return result;
    }
    /**
     * Handler for onChanged events.
     *
     * @param {ResourceChangeEvent} event Event name.
     * @param {Resource} resources A collection of resources changed.
     */
    onChanged(event, resources) {
        if (this._eventEmitter) {
            this._eventEmitter.emit(event, resources);
        }
    }
    load(value) {
        const kind = value['$kind'];
        const type = this._kindToType.get(kind);
        if (!type) {
            throw new Error(`Type ${kind} not registered.`);
        }
        const loader = this._kindDeserializer.get(kind);
        return loader.load(value, type);
    }
    // preload type into cache.
    preload(kind, resourceId) {
        const type = this._kindToType.get(kind);
        if (!type) {
            throw new Error(`Type ${kind} not registered.`);
        }
        const result = new type();
        this._cache.set(resourceId, result);
        return result;
    }
    registerTypeInternal(kind, type, loader) {
        this._kindToType.set(kind, type);
        this._kindDeserializer.set(kind, loader !== null && loader !== void 0 ? loader : new defaultLoader_1.DefaultLoader(this));
    }
    registerComponentTypes() {
        if (this._typesLoaded) {
            return;
        }
        this._typesLoaded = true;
        this._declarativeTypes.forEach((component) => {
            component.getDeclarativeTypes(this).forEach((declarativeType) => {
                const { kind, type, loader } = declarativeType;
                this.registerTypeInternal(kind, type, loader);
            });
        });
    }
}
exports.ResourceExplorer = ResourceExplorer;
//# sourceMappingURL=resourceExplorer.js.map