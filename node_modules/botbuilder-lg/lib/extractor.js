"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const tree_1 = require("antlr4ts/tree");
const lodash_1 = require("lodash");
/**
 * Lg template extracter.
 */
class Extractor extends tree_1.AbstractParseTreeVisitor {
    /**
     * Creates a new instance of the [Extractor](xref:botbuilder-lg.Extractor) class.
     * @param templates Template list.
     */
    constructor(templates) {
        super();
        this.templates = templates;
        this.templateMap = lodash_1.keyBy(templates, (t) => t.name);
    }
    /**
     * Extracts the templates and returns a map with their names and bodies.
     * @returns Map object with template names and bodies.
     */
    extract() {
        const result = [];
        this.templates.forEach((template) => {
            const templateResult = new Map();
            const templateName = template.name;
            const templateBodies = this.visit(template.templateBodyParseTree);
            let isNormalTemplate = true;
            templateBodies.forEach((templateBody) => (isNormalTemplate = isNormalTemplate && templateBody === undefined));
            if (isNormalTemplate) {
                const templates = [];
                for (const templateBody of templateBodies) {
                    templates.push(templateBody[0]);
                }
                templateResult.set(templateName, templates);
            }
            else {
                templateResult.set(templateName, templateBodies);
            }
            result.push(templateResult);
        });
        return result;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateBody.
     * @param context The parse tree.
     * @returns The result of visiting the normal template body.
     */
    visitNormalTemplateBody(context) {
        const result = new Map();
        for (const templateStr of context.templateString()) {
            result.set(templateStr.normalTemplateString().text, undefined);
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the structuredBody labeled alternative in LGTemplateParser.body.
     * @param context The parse tree.
     * @returns The result of visiting the structured body.
     */
    visitStructuredBody(context) {
        const result = new Map();
        const lineStart = '    ';
        const structName = context.structuredTemplateBody().structuredBodyNameLine().text;
        let fullStr = structName + '\n';
        context
            .structuredTemplateBody()
            .structuredBodyContentLine()
            .forEach((line) => (fullStr += lineStart + line.text + '\n'));
        fullStr += context.structuredTemplateBody().structuredBodyEndLine().text;
        result.set(fullStr, undefined);
        return result;
    }
    /**
     * Visit a parse tree produced by the ifElseBody labeled alternative in LGTemplateParser.body.
     * @param context The parse tree.
     * @returns The result of visiting the if else body.
     */
    visitIfElseBody(context) {
        const result = new Map();
        const ifRules = context.ifElseTemplateBody().ifConditionRule();
        for (const ifRule of ifRules) {
            const expressions = ifRule.ifCondition().expression();
            const conditionNode = ifRule.ifCondition();
            const ifExpr = conditionNode.IF() !== undefined;
            const elseIfExpr = conditionNode.ELSEIF() !== undefined;
            const node = ifExpr
                ? conditionNode.IF()
                : elseIfExpr
                    ? conditionNode.ELSEIF()
                    : conditionNode.ELSE();
            const conditionLabel = node.text.toLowerCase();
            const childTemplateBodyResult = [];
            const templateBodies = this.visit(ifRule.normalTemplateBody());
            for (const templateBody of templateBodies) {
                childTemplateBodyResult.push(templateBody[0]);
            }
            if (expressions !== undefined && expressions.length > 0) {
                if (expressions[0].text !== undefined) {
                    result.set(conditionLabel.toUpperCase().concat(' ') + expressions[0].text, childTemplateBodyResult);
                }
            }
            else {
                result.set('ELSE:', childTemplateBodyResult);
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the switchCaseBody labeled alternative in LGTemplateParser.body.
     * @param context The parse tree.
     * @returns The result of visiting the switch case body.
     */
    visitSwitchCaseBody(context) {
        const result = new Map();
        const switchCaseNodes = context.switchCaseTemplateBody().switchCaseRule();
        for (const iterNode of switchCaseNodes) {
            const expressions = iterNode.switchCaseStat().expression();
            const switchCaseStat = iterNode.switchCaseStat();
            const switchExpr = switchCaseStat.SWITCH() !== undefined;
            const caseExpr = switchCaseStat.CASE() !== undefined;
            const node = switchExpr
                ? switchCaseStat.SWITCH()
                : caseExpr
                    ? switchCaseStat.CASE()
                    : switchCaseStat.DEFAULT();
            if (switchExpr) {
                continue;
            }
            const conditionLabel = node.text.toLowerCase();
            const childTemplateBodyResult = [];
            const templateBodies = this.visit(iterNode.normalTemplateBody());
            for (const templateBody of templateBodies) {
                childTemplateBodyResult.push(templateBody[0]);
            }
            if (caseExpr) {
                result.set(conditionLabel.toUpperCase().concat(' ') + expressions[0].text, childTemplateBodyResult);
            }
            else {
                result.set('DEFALUT:', childTemplateBodyResult);
            }
        }
        return result;
    }
    /**
     * Gets the default value returned by visitor methods.
     * @returns Empty Map<string,  string[]>.
     */
    defaultResult() {
        return new Map();
    }
}
exports.Extractor = Extractor;
//# sourceMappingURL=extractor.js.map