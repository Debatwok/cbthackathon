"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable security/detect-object-injection */
/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const tree_1 = require("antlr4ts/tree");
const adaptive_expressions_1 = require("adaptive-expressions");
const lodash_1 = require("lodash");
const evaluationTarget_1 = require("./evaluationTarget");
const evaluator_1 = require("./evaluator");
const path = require("path");
const fs = require("fs");
const lp = require("./generated/LGTemplateParser");
const templateExtensions_1 = require("./templateExtensions");
const customizedMemory_1 = require("./customizedMemory");
const templateErrors_1 = require("./templateErrors");
const templates_1 = require("./templates");
/**
 * LG template expander.
 */
class Expander extends tree_1.AbstractParseTreeVisitor {
    /**
     * Creates a new instance of the Expander class.
     * @param templates Template list.
     * @param expressionParser Given expression parser.
     * @param opt Options for LG.
     */
    constructor(templates, opt) {
        super();
        this.evaluationTargetStack = [];
        this.customizedEvaluatorLookup = (baseLookup, isExpander) => (name) => {
            const standardFunction = baseLookup(name);
            if (standardFunction !== undefined) {
                return standardFunction;
            }
            const pointIndex = name.indexOf('.');
            if (pointIndex > 0) {
                const alias = name.substr(0, pointIndex);
                const realTemplate = this.templates.namedReferences[alias];
                if (realTemplate) {
                    const realTemplateName = name.substr(pointIndex + 1);
                    return new adaptive_expressions_1.ExpressionEvaluator(realTemplateName, adaptive_expressions_1.FunctionUtils.apply(this.evaluateWithTemplates(realTemplateName, realTemplate)), adaptive_expressions_1.ReturnType.Object);
                }
            }
            if (name.startsWith('lg.')) {
                name = name.substring(3);
            }
            const templateName = this.parseTemplateName(name).pureTemplateName;
            if (templateName in this.templateMap) {
                if (isExpander) {
                    return new adaptive_expressions_1.ExpressionEvaluator(templateName, adaptive_expressions_1.FunctionUtils.apply(this.templateExpander(name)), adaptive_expressions_1.ReturnType.Object, this.validTemplateReference);
                }
                else {
                    return new adaptive_expressions_1.ExpressionEvaluator(templateName, adaptive_expressions_1.FunctionUtils.apply(this.templateEvaluator(name)), adaptive_expressions_1.ReturnType.Object, this.validTemplateReference);
                }
            }
            if (name === evaluator_1.Evaluator.templateFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(evaluator_1.Evaluator.templateFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.templateFunction()), adaptive_expressions_1.ReturnType.Object, this.validateTemplateFunction);
            }
            if (name === evaluator_1.Evaluator.fromFileFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(evaluator_1.Evaluator.fromFileFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.fromFile()), adaptive_expressions_1.ReturnType.Object, (expr) => adaptive_expressions_1.FunctionUtils.validateOrder(expr, [adaptive_expressions_1.ReturnType.String], adaptive_expressions_1.ReturnType.String));
            }
            if (name === evaluator_1.Evaluator.activityAttachmentFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(evaluator_1.Evaluator.activityAttachmentFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.activityAttachment()), adaptive_expressions_1.ReturnType.Object, (expr) => adaptive_expressions_1.FunctionUtils.validateOrder(expr, undefined, adaptive_expressions_1.ReturnType.Object, adaptive_expressions_1.ReturnType.String));
            }
            if (name === evaluator_1.Evaluator.isTemplateFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(evaluator_1.Evaluator.isTemplateFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.isTemplate()), adaptive_expressions_1.ReturnType.Boolean, adaptive_expressions_1.FunctionUtils.validateUnaryString);
            }
            if (name === evaluator_1.Evaluator.expandTextFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(evaluator_1.Evaluator.expandTextFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.expandText()), adaptive_expressions_1.ReturnType.Object, adaptive_expressions_1.FunctionUtils.validateUnaryString);
            }
            return undefined;
        };
        this.evaluateWithTemplates = (templateName, templates) => (args) => {
            const newScope = this.constructScope(templateName, args.slice(0), templates.allTemplates);
            return templates.evaluate(templateName, newScope);
        };
        this.templateEvaluator = (templateName) => (args) => {
            const newScope = this.constructScope(templateName, Array.from(args), this.templates.allTemplates);
            const value = this.expandTemplate(templateName, newScope);
            const randomNumber = adaptive_expressions_1.Extensions.randomNext(this.currentTarget().scope, 0, value.length);
            return value[randomNumber];
        };
        this.templateExpander = (templateName) => (args) => {
            const newScope = this.constructScope(templateName, Array.from(args), this.templates.allTemplates);
            return this.expandTemplate(templateName, newScope);
        };
        this.isTemplate = () => (args) => {
            const templateName = args[0].toString();
            return templateName in this.templateMap;
        };
        this.fromFile = () => (args) => {
            const filePath = templateExtensions_1.TemplateExtensions.normalizePath(args[0].toString());
            const resourcePath = this.getResourcePath(filePath);
            let format = evaluator_1.FileFormat.Evaluated;
            if (args.length > 1) {
                const expected = args[1].toString().toLowerCase();
                const currentFormat = Object.values(evaluator_1.FileFormat).find((f) => f.toLowerCase() === expected);
                if (currentFormat != null) {
                    format = currentFormat;
                }
            }
            let result;
            if (format === evaluator_1.FileFormat.Binary) {
                result = fs.readFileSync(resourcePath);
            }
            else if (format === evaluator_1.FileFormat.Raw) {
                result = fs.readFileSync(resourcePath, 'utf-8');
            }
            else {
                const stringContent = fs.readFileSync(resourcePath, 'utf-8');
                const newScope = this.evaluationTargetStack.length > 0 ? this.currentTarget().scope : undefined;
                const newTemplates = new templates_1.Templates(this.templates.allTemplates, undefined, undefined, undefined, undefined, undefined, this.templates.expressionParser, undefined, [], undefined, this.templates.namedReferences);
                result = newTemplates.evaluateText(stringContent, newScope, this.lgOptions);
            }
            return result;
        };
        this.expandText = () => (args) => {
            const stringContent = args[0].toString();
            const newScope = this.evaluationTargetStack.length > 0 ? this.currentTarget().scope : undefined;
            const newTemplates = new templates_1.Templates(this.templates.allTemplates, undefined, undefined, undefined, undefined, undefined, this.templates.expressionParser, undefined, [], undefined, this.templates.namedReferences);
            return newTemplates.evaluateText(stringContent, newScope, this.lgOptions);
        };
        this.activityAttachment = () => (args) => {
            return {
                [evaluator_1.Evaluator.LGType]: 'attachment',
                contenttype: args[1].toString(),
                content: args[0],
            };
        };
        this.templateFunction = () => (args) => {
            const templateName = args[0].toString();
            const newScope = this.constructScope(templateName, args.slice(1), this.templates.allTemplates);
            const value = this.expandTemplate(templateName, newScope);
            return value;
        };
        this.validateTemplateFunction = (expression) => {
            adaptive_expressions_1.FunctionUtils.validateAtLeastOne(expression);
            const children0 = expression.children[0];
            // Validate return type
            if ((children0.returnType & adaptive_expressions_1.ReturnType.Object) === 0 && (children0.returnType & adaptive_expressions_1.ReturnType.String) === 0) {
                throw new Error(templateErrors_1.TemplateErrors.invalidTemplateNameType);
            }
            // Validate more if the name is string constant
            if (children0.type === adaptive_expressions_1.ExpressionType.Constant) {
                const templateName = children0.value;
                this.checkTemplateReference(templateName, expression.children.slice(1));
            }
        };
        this.validTemplateReference = (expression) => {
            return this.checkTemplateReference(expression.type, expression.children);
        };
        this.templates = templates;
        this.templateMap = lodash_1.keyBy(templates.allTemplates, (t) => t.name);
        this.lgOptions = opt;
        // generate a new customzied expression parser by injecting the template as functions
        this.expanderExpressionParser = new adaptive_expressions_1.ExpressionParser(this.customizedEvaluatorLookup(templates.expressionParser.EvaluatorLookup, true));
        this.evaluatorExpressionParser = new adaptive_expressions_1.ExpressionParser(this.customizedEvaluatorLookup(templates.expressionParser.EvaluatorLookup, false));
    }
    /**
     * Expand the results of a template with given name and scope.
     * @param templateName Given template name.
     * @param scope Given scope.
     * @returns All possiable results.
     */
    expandTemplate(templateName, scope) {
        const memory = scope instanceof customizedMemory_1.CustomizedMemory ? scope : new customizedMemory_1.CustomizedMemory(scope);
        if (!(templateName in this.templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const templateTarget = new evaluationTarget_1.EvaluationTarget(templateName, memory);
        const currentEvulateId = templateTarget.getId();
        if (this.evaluationTargetStack.find((u) => u.getId() === currentEvulateId)) {
            throw new Error(`${templateErrors_1.TemplateErrors.loopDetected} ${this.evaluationTargetStack
                .reverse()
                .map((u) => u.templateName)
                .join(' => ')}`);
        }
        // Using a stack to track the evalution trace
        this.evaluationTargetStack.push(templateTarget);
        const result = this.visit(this.templateMap[templateName].templateBodyParseTree);
        this.evaluationTargetStack.pop();
        return result;
    }
    /**
     * Visit a parse tree produced by the normalBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal body.
     */
    visitNormalBody(ctx) {
        return this.visit(ctx.normalTemplateBody());
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal template body.
     */
    visitNormalTemplateBody(ctx) {
        const normalTemplateStrs = ctx.templateString();
        let result = [];
        for (const normalTemplateStr of normalTemplateStrs) {
            result = result.concat(this.visit(normalTemplateStr.normalTemplateString()));
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the ifElseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     */
    visitIfElseBody(ctx) {
        const ifRules = ctx.ifElseTemplateBody().ifConditionRule();
        for (const ifRule of ifRules) {
            if (this.evalCondition(ifRule.ifCondition()) && ifRule.normalTemplateBody() !== undefined) {
                return this.visit(ifRule.normalTemplateBody());
            }
        }
        return undefined;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.structuredBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the structured body.
     */
    visitStructuredBody(ctx) {
        const templateRefValues = new Map();
        const stb = ctx.structuredTemplateBody();
        const result = {};
        const typeName = stb.structuredBodyNameLine().STRUCTURE_NAME().text.trim();
        result.lgType = typeName;
        let expandedResult = [result];
        const bodys = stb.structuredBodyContentLine();
        for (const body of bodys) {
            const isKVPairBody = body.keyValueStructureLine() !== undefined;
            if (isKVPairBody) {
                const property = body.keyValueStructureLine().STRUCTURE_IDENTIFIER().text.toLowerCase();
                const value = this.visitStructureValue(body.keyValueStructureLine());
                if (value && value.length > 0) {
                    if (value.length > 1) {
                        const valueList = [];
                        for (const item of value) {
                            const id = templateExtensions_1.TemplateExtensions.newGuid();
                            if (item.length > 0) {
                                valueList.push(id);
                                templateRefValues.set(id, item);
                            }
                            else {
                                valueList.push([]);
                            }
                        }
                        expandedResult.forEach((x) => (x[property] = valueList));
                    }
                    else {
                        const id = templateExtensions_1.TemplateExtensions.newGuid();
                        if (value[0].length > 0) {
                            expandedResult.forEach((x) => (x[property] = id));
                            templateRefValues.set(id, value[0]);
                        }
                        else {
                            expandedResult.forEach((x) => (x[property] = []));
                        }
                    }
                }
            }
            else {
                const propertyObjects = [];
                this.evalExpression(body.expressionInStructure().text, body.expressionInStructure(), body.text).forEach((x) => {
                    if (x !== undefined && x !== null) {
                        propertyObjects.push(x);
                    }
                });
                const tempResult = [];
                for (const res of expandedResult) {
                    for (const propertyObject of propertyObjects) {
                        const tempRes = JSON.parse(JSON.stringify(res));
                        // Full reference to another structured template is limited to the structured template with same type
                        if (typeof propertyObject === 'object' &&
                            evaluator_1.Evaluator.LGType in propertyObject &&
                            propertyObject[evaluator_1.Evaluator.LGType].toString() === typeName) {
                            for (const key of Object.keys(propertyObject)) {
                                if (propertyObject.hasOwnProperty(key) && !(key in tempRes)) {
                                    tempRes[key] = propertyObject[key];
                                }
                            }
                        }
                        tempResult.push(tempRes);
                    }
                }
                expandedResult = tempResult;
            }
        }
        const exps = expandedResult;
        let finalResult = exps;
        for (const templateRefValueKey of templateRefValues.keys()) {
            const tempRes = [];
            for (const res of finalResult) {
                for (const refValue of templateRefValues.get(templateRefValueKey)) {
                    tempRes.push(JSON.parse(JSON.stringify(res).replace(templateRefValueKey, refValue.toString().replace(/"/g, '\\"'))));
                }
            }
            finalResult = tempRes;
        }
        return finalResult;
    }
    /**
     * @private
     */
    visitStructureValue(ctx) {
        const values = ctx.keyValueStructureValue();
        const result = [];
        for (const item of values) {
            if (templateExtensions_1.TemplateExtensions.isPureExpression(item)) {
                result.push(this.evalExpression(item.expressionInStructure(0).text, item.expressionInStructure(0), ctx.text));
            }
            else {
                let itemStringResult = [''];
                for (const child of item.children) {
                    if (child instanceof lp.ExpressionInStructureContext) {
                        const errorPrefix = `Property '${ctx.STRUCTURE_IDENTIFIER().text}':`;
                        itemStringResult = this.stringArrayConcat(itemStringResult, this.evalExpression(child.text, child, ctx.text, errorPrefix));
                    }
                    else {
                        const node = child;
                        switch (node.symbol.type) {
                            case lp.LGTemplateParser.ESCAPE_CHARACTER_IN_STRUCTURE_BODY:
                                itemStringResult = this.stringArrayConcat(itemStringResult, [
                                    templateExtensions_1.TemplateExtensions.evalEscape(node.text.replace(/\\\|/g, '|')),
                                ]);
                                break;
                            default:
                                itemStringResult = this.stringArrayConcat(itemStringResult, [node.text]);
                                break;
                        }
                    }
                }
                result.push(itemStringResult);
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the switchCaseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The result of visiting the switch case body.
     */
    visitSwitchCaseBody(ctx) {
        const switchcaseNodes = ctx.switchCaseTemplateBody().switchCaseRule();
        const length = switchcaseNodes.length;
        const switchNode = switchcaseNodes[0];
        const switchExprs = switchNode.switchCaseStat().expression();
        const switchErrorPrefix = `Switch '${switchExprs[0].text}': `;
        const switchExprResult = this.evalExpression(switchExprs[0].text, switchExprs[0], switchcaseNodes[0].switchCaseStat().text, switchErrorPrefix);
        let idx = 0;
        for (const caseNode of switchcaseNodes) {
            if (idx === 0) {
                idx++;
                continue; //skip the first node which is a switch statement
            }
            if (idx === length - 1 && caseNode.switchCaseStat().DEFAULT()) {
                const defaultBody = caseNode.normalTemplateBody();
                if (defaultBody) {
                    return this.visit(defaultBody);
                }
                else {
                    return undefined;
                }
            }
            const caseExprs = caseNode.switchCaseStat().expression();
            const caseErrorPrefix = `Case '${caseExprs[0].text}': `;
            const caseExprResult = this.evalExpression(caseExprs[0].text, caseExprs[0], caseNode.switchCaseStat().text, caseErrorPrefix);
            if (adaptive_expressions_1.FunctionUtils.commonEquals(switchExprResult[0], caseExprResult[0])) {
                return this.visit(caseNode.normalTemplateBody());
            }
            idx++;
        }
        return undefined;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateString.
     * @param ctx The parse tree.
     */
    visitNormalTemplateString(ctx) {
        const prefixErrorMsg = templateExtensions_1.TemplateExtensions.getPrefixErrorMessage(ctx);
        let result = [undefined];
        for (const child of ctx.children) {
            if (child instanceof lp.ExpressionContext) {
                result = this.stringArrayConcat(result, this.evalExpression(child.text, child, ctx.text, prefixErrorMsg));
            }
            else {
                const node = child;
                switch (node.symbol.type) {
                    case lp.LGTemplateParser.MULTILINE_PREFIX:
                    case lp.LGTemplateParser.MULTILINE_SUFFIX:
                    case lp.LGTemplateParser.DASH:
                        break;
                    case lp.LGTemplateParser.ESCAPE_CHARACTER:
                        result = this.stringArrayConcat(result, [templateExtensions_1.TemplateExtensions.evalEscape(node.text)]);
                        break;
                    default: {
                        result = this.stringArrayConcat(result, [node.text]);
                        break;
                    }
                }
            }
        }
        return result;
    }
    /**
     * Constructs the scope for mapping the values of arguments to the parameters of the template.
     * @param templateName The template name to evaluate.
     * @param args Arguments to map to the template parameters.
     * @param allTemplates All templates.
     * @returns The current scope if the number of arguments is 0, otherwise, returns a CustomizedMemory
     * with the mapping of the parameter name to the argument value added to the scope.
     */
    constructScope(inputTemplateName, args, allTemplates) {
        const templateName = this.parseTemplateName(inputTemplateName).pureTemplateName;
        const templateMap = lodash_1.keyBy(allTemplates, (t) => t.name);
        if (!(templateName in templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const parameters = templateMap[templateName].parameters;
        const currentScope = this.currentTarget().scope;
        if (args.length === 0) {
            // no args to construct, inherit from current scope
            return currentScope;
        }
        const newScope = {};
        parameters.map((e, i) => (newScope[e] = args[i]));
        const memory = currentScope;
        if (!memory) {
            throw new Error(templateErrors_1.TemplateErrors.invalidMemory);
        }
        return new customizedMemory_1.CustomizedMemory(memory.globalMemory, adaptive_expressions_1.SimpleObjectMemory.wrap(newScope));
    }
    /**
     * Gets the default value returned by visitor methods.
     * @returns Empty string array.
     */
    defaultResult() {
        return [];
    }
    /**
     * @private
     */
    currentTarget() {
        return this.evaluationTargetStack[this.evaluationTargetStack.length - 1];
    }
    /**
     * @private
     */
    evalCondition(condition) {
        const expression = condition.expression()[0];
        if (!expression) {
            return true; // no expression means it's else
        }
        if (this.evalExpressionInCondition(expression, condition.text, `Condition '` + expression.text + `':`)) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    evalExpressionInCondition(expressionContext, contentLine, errorPrefix = '') {
        const exp = templateExtensions_1.TemplateExtensions.trimExpression(expressionContext.text);
        const { value: result, error: error } = this.evalByAdaptiveExpression(exp, this.currentTarget().scope);
        if (this.lgOptions.strictMode && (error || !result)) {
            const templateName = this.currentTarget().templateName;
            if (this.evaluationTargetStack.length > 0) {
                this.evaluationTargetStack.pop();
            }
            evaluator_1.Evaluator.checkExpressionResult(exp, error, result, templateName, contentLine, errorPrefix);
        }
        else if (error || !result) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    evalExpression(exp, context, inlineContent = '', errorPrefix = '') {
        exp = templateExtensions_1.TemplateExtensions.trimExpression(exp);
        const { value: result, error: error } = this.evalByAdaptiveExpression(exp, this.currentTarget().scope);
        if (error || (result === undefined && this.lgOptions.strictMode)) {
            const templateName = this.currentTarget().templateName;
            if (this.evaluationTargetStack.length > 0) {
                this.evaluationTargetStack.pop();
            }
            evaluator_1.Evaluator.checkExpressionResult(exp, error, result, templateName, inlineContent, errorPrefix);
        }
        if (Array.isArray(result)) {
            return result;
        }
        return [result];
    }
    /**
     * @private
     */
    evalByAdaptiveExpression(exp, scope) {
        const expanderExpression = this.expanderExpressionParser.parse(exp);
        const evaluatorExpression = this.evaluatorExpressionParser.parse(exp);
        const parse = this.reconstructExpression(expanderExpression, evaluatorExpression, false);
        const opt = new adaptive_expressions_1.Options();
        opt.nullSubstitution = this.lgOptions.nullSubstitution;
        opt.locale = this.lgOptions.locale;
        return parse.tryEvaluate(scope, opt);
    }
    /**
     * @private
     */
    stringArrayConcat(array1, array2) {
        const result = [];
        for (const item1 of array1) {
            for (const item2 of array2) {
                if (item1 === undefined && item2 === undefined) {
                    result.push(undefined);
                }
                else {
                    result.push(this.stringConcat(item1, item2));
                }
            }
        }
        return result;
    }
    stringConcat(str1, str2) {
        if (!str1) {
            str1 = '';
        }
        if (!str2) {
            str2 = '';
        }
        return str1.toString() + str2.toString();
    }
    /**
     * @private
     */
    reconstructExpression(expanderExpression, evaluatorExpression, foundPrebuiltFunction) {
        if (this.templateMap[expanderExpression.type]) {
            if (foundPrebuiltFunction) {
                return evaluatorExpression;
            }
        }
        else {
            foundPrebuiltFunction = true;
        }
        for (let i = 0; i < expanderExpression.children.length; i++) {
            expanderExpression.children[i] = this.reconstructExpression(expanderExpression.children[i], evaluatorExpression.children[i], foundPrebuiltFunction);
        }
        return expanderExpression;
    }
    /**
     * @private
     */
    getResourcePath(filePath) {
        let resourcePath;
        if (path.isAbsolute(filePath)) {
            resourcePath = filePath;
        }
        else {
            // relative path is not support in broswer environment
            const inBrowser = typeof window !== 'undefined';
            if (inBrowser) {
                throw new Error('relative path is not support in browser.');
            }
            const template = this.templateMap[this.currentTarget().templateName];
            const sourcePath = templateExtensions_1.TemplateExtensions.normalizePath(template.sourceRange.source);
            let baseFolder = __dirname;
            if (path.isAbsolute(sourcePath)) {
                baseFolder = path.dirname(sourcePath);
            }
            resourcePath = path.join(baseFolder, filePath);
        }
        return resourcePath;
    }
    /**
     * @private
     */
    checkTemplateReference(templateName, children) {
        if (!(templateName in this.templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const expectedArgsCount = this.templateMap[templateName].parameters.length;
        const actualArgsCount = children.length;
        if (actualArgsCount !== 0 && expectedArgsCount !== actualArgsCount) {
            throw new Error(templateErrors_1.TemplateErrors.argumentMismatch(templateName, expectedArgsCount, actualArgsCount));
        }
    }
    /**
     * @private
     */
    parseTemplateName(templateName) {
        if (!templateName) {
            throw new Error('template name is empty.');
        }
        if (templateName.endsWith(evaluator_1.Evaluator.ReExecuteSuffix)) {
            return {
                reExecute: true,
                pureTemplateName: templateName.substr(0, templateName.length - evaluator_1.Evaluator.ReExecuteSuffix.length),
            };
        }
        else {
            return { reExecute: false, pureTemplateName: templateName };
        }
    }
}
exports.Expander = Expander;
//# sourceMappingURL=expander.js.map