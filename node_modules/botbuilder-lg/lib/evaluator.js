"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable security/detect-object-injection */
/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const tree_1 = require("antlr4ts/tree");
const adaptive_expressions_1 = require("adaptive-expressions");
const lodash_1 = require("lodash");
const customizedMemory_1 = require("./customizedMemory");
const evaluationTarget_1 = require("./evaluationTarget");
const lp = require("./generated/LGTemplateParser");
const path = require("path");
const fs = require("fs");
const templateExtensions_1 = require("./templateExtensions");
const templateErrors_1 = require("./templateErrors");
const evaluationOptions_1 = require("./evaluationOptions");
const templates_1 = require("./templates");
/**
 * Filr formats.
 */
var FileFormat;
(function (FileFormat) {
    /**
     * Get the evaluated result from the Raw.
     */
    FileFormat["Evaluated"] = "Evaluated";
    /**
     * Get raw text content of the file.
     */
    FileFormat["Raw"] = "Raw";
    /**
     * Get binary result from the file.
     */
    FileFormat["Binary"] = "Binary";
})(FileFormat = exports.FileFormat || (exports.FileFormat = {}));
/**
 * Evaluation runtime engine
 */
class Evaluator extends tree_1.AbstractParseTreeVisitor {
    /**
     * Creates a new instance of the [Evaluator](xref:botbuilder-lg.Evaluator) class.
     * @param templates Templates.
     * @param opt Options for LG.
     */
    constructor(templates, opt) {
        super();
        this.evaluationTargetStack = [];
        this.cacheResult = new Map();
        // Genearte a new lookup function based on one lookup function
        this.customizedEvaluatorLookup = (baseLookup) => (name) => {
            const standardFunction = baseLookup(name);
            if (standardFunction !== undefined) {
                return standardFunction;
            }
            const pointIndex = name.indexOf('.');
            if (pointIndex > 0) {
                const alias = name.substr(0, pointIndex);
                const realTemplate = this.templates.namedReferences[alias];
                if (realTemplate) {
                    const realTemplateName = name.substr(pointIndex + 1);
                    return new adaptive_expressions_1.ExpressionEvaluator(realTemplateName, adaptive_expressions_1.FunctionUtils.apply(this.evaluateWithTemplates(realTemplateName, realTemplate)), adaptive_expressions_1.ReturnType.Object);
                }
            }
            if (name.startsWith('lg.')) {
                name = name.substring(3);
            }
            const templateName = this.parseTemplateName(name).pureTemplateName;
            if (templateName in this.templateMap) {
                return new adaptive_expressions_1.ExpressionEvaluator(templateName, adaptive_expressions_1.FunctionUtils.apply(this.templateEvaluator(name)), adaptive_expressions_1.ReturnType.Object, this.validTemplateReference);
            }
            if (name === Evaluator.templateFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(Evaluator.templateFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.templateFunction()), adaptive_expressions_1.ReturnType.Object, this.validateTemplateFunction);
            }
            if (name === Evaluator.fromFileFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(Evaluator.fromFileFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.fromFile()), adaptive_expressions_1.ReturnType.Object, (expr) => adaptive_expressions_1.FunctionUtils.validateOrder(expr, [adaptive_expressions_1.ReturnType.String], adaptive_expressions_1.ReturnType.String));
            }
            if (name === Evaluator.activityAttachmentFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(Evaluator.activityAttachmentFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.activityAttachment()), adaptive_expressions_1.ReturnType.Object, (expr) => adaptive_expressions_1.FunctionUtils.validateOrder(expr, undefined, adaptive_expressions_1.ReturnType.Object, adaptive_expressions_1.ReturnType.String));
            }
            if (name === Evaluator.isTemplateFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(Evaluator.isTemplateFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.isTemplate()), adaptive_expressions_1.ReturnType.Boolean, adaptive_expressions_1.FunctionUtils.validateUnaryString);
            }
            if (name === Evaluator.expandTextFunctionName) {
                return new adaptive_expressions_1.ExpressionEvaluator(Evaluator.expandTextFunctionName, adaptive_expressions_1.FunctionUtils.apply(this.expandText()), adaptive_expressions_1.ReturnType.Object, adaptive_expressions_1.FunctionUtils.validateUnaryString);
            }
            return undefined;
        };
        this.isTemplate = () => (args) => {
            const templateName = args[0].toString();
            return templateName in this.templateMap;
        };
        this.fromFile = () => (args) => {
            const filePath = templateExtensions_1.TemplateExtensions.normalizePath(args[0].toString());
            const resourcePath = this.getResourcePath(filePath);
            let format = FileFormat.Evaluated;
            if (args.length > 1) {
                const expected = args[1].toString().toLowerCase();
                const currentFormat = Object.values(FileFormat).find((f) => f.toLowerCase() === expected);
                if (currentFormat != null) {
                    format = currentFormat;
                }
            }
            let result;
            if (format === FileFormat.Binary) {
                result = fs.readFileSync(resourcePath);
            }
            else if (format === FileFormat.Raw) {
                result = fs.readFileSync(resourcePath, 'utf-8');
            }
            else {
                const stringContent = fs.readFileSync(resourcePath, 'utf-8');
                const newScope = this.evaluationTargetStack.length > 0 ? this.currentTarget().scope : undefined;
                const newTemplates = new templates_1.Templates(this.templates.allTemplates, undefined, undefined, undefined, undefined, undefined, this.expressionParser, undefined, [], undefined, this.templates.namedReferences);
                result = newTemplates.evaluateText(stringContent, newScope, this.lgOptions);
            }
            return result;
        };
        this.expandText = () => (args) => {
            const stringContent = args[0].toString();
            const newScope = this.evaluationTargetStack.length > 0 ? this.currentTarget().scope : undefined;
            const newTemplates = new templates_1.Templates(this.templates.allTemplates, undefined, undefined, undefined, undefined, undefined, this.expressionParser, undefined, [], undefined, this.templates.namedReferences);
            return newTemplates.evaluateText(stringContent, newScope, this.lgOptions);
        };
        this.activityAttachment = () => (args) => {
            return {
                [Evaluator.LGType]: 'attachment',
                contenttype: args[1].toString(),
                content: args[0],
            };
        };
        this.evaluateWithTemplates = (templateName, templates) => (args) => {
            const newScope = this.constructScope(templateName, args.slice(0), templates.allTemplates);
            return templates.evaluate(templateName, newScope);
        };
        this.templateFunction = () => (args) => {
            const templateName = args[0].toString();
            const newScope = this.constructScope(templateName, args.slice(1), this.templates.allTemplates);
            return this.evaluateTemplate(templateName, newScope);
        };
        this.validateTemplateFunction = (expression) => {
            adaptive_expressions_1.FunctionUtils.validateAtLeastOne(expression);
            const children0 = expression.children[0];
            // Validate return type
            if ((children0.returnType & adaptive_expressions_1.ReturnType.Object) === 0 && (children0.returnType & adaptive_expressions_1.ReturnType.String) === 0) {
                throw new Error(templateErrors_1.TemplateErrors.invalidTemplateNameType);
            }
            // Validate more if the name is string constant
            if (children0.type === adaptive_expressions_1.ExpressionType.Constant) {
                const templateName = children0.value;
                this.checkTemplateReference(templateName, expression.children.slice(1));
            }
        };
        this.templateEvaluator = (templateName) => (args) => {
            const newScope = this.constructScope(templateName, Array.from(args), this.templates.allTemplates);
            return this.evaluateTemplate(templateName, newScope);
        };
        this.validTemplateReference = (expression) => {
            return this.checkTemplateReference(expression.type, expression.children);
        };
        this.templates = templates;
        this.templateMap = lodash_1.keyBy(templates.allTemplates, (t) => t.name);
        this.lgOptions = opt;
        this.cacheResult.clear();
        // generate a new customzied expression parser by injecting the templates as functions
        this.expressionParser = new adaptive_expressions_1.ExpressionParser(this.customizedEvaluatorLookup(templates.expressionParser.EvaluatorLookup));
    }
    /**
     * Evaluate a template with given name and scope.
     * @param inputTemplateName Template name.
     * @param scope Scope.
     * @returns Evaluate result.
     */
    evaluateTemplate(inputTemplateName, scope) {
        const memory = scope instanceof customizedMemory_1.CustomizedMemory ? scope : new customizedMemory_1.CustomizedMemory(scope);
        const { reExecute, pureTemplateName: templateName } = this.parseTemplateName(inputTemplateName);
        if (!(templateName in this.templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const templateTarget = new evaluationTarget_1.EvaluationTarget(templateName, memory);
        const currentEvulateId = templateTarget.getId();
        if (this.evaluationTargetStack.some((u) => u.getId() === currentEvulateId)) {
            throw new Error(`${templateErrors_1.TemplateErrors.loopDetected} ${this.evaluationTargetStack
                .reverse()
                .map((u) => u.templateName)
                .join(' => ')}`);
        }
        let result;
        let hasResult = false;
        if (!reExecute) {
            if (this.lgOptions.cacheScope === evaluationOptions_1.LGCacheScope.Global) {
                if (this.cacheResult.has(currentEvulateId)) {
                    result = this.cacheResult.get(currentEvulateId);
                    hasResult = true;
                }
            }
            else if (this.lgOptions.cacheScope === undefined || this.lgOptions.cacheScope === evaluationOptions_1.LGCacheScope.Local) {
                let previousEvaluateTarget;
                if (this.evaluationTargetStack.length !== 0) {
                    previousEvaluateTarget = this.evaluationTargetStack[this.evaluationTargetStack.length - 1];
                    if (previousEvaluateTarget.cachedEvaluatedChildren.has(currentEvulateId)) {
                        result = previousEvaluateTarget.cachedEvaluatedChildren.get(currentEvulateId);
                        hasResult = true;
                    }
                }
            }
        }
        if (!hasResult) {
            this.evaluationTargetStack.push(templateTarget);
            result = this.visit(this.templateMap[templateName].templateBodyParseTree);
            this.evaluationTargetStack.pop();
            if (!reExecute) {
                if (this.lgOptions.cacheScope === evaluationOptions_1.LGCacheScope.Global) {
                    this.cacheResult.set(currentEvulateId, result);
                }
                else if (this.lgOptions.cacheScope === undefined ||
                    this.lgOptions.cacheScope === evaluationOptions_1.LGCacheScope.Local) {
                    if (this.evaluationTargetStack.length !== 0) {
                        this.evaluationTargetStack[this.evaluationTargetStack.length - 1].cachedEvaluatedChildren.set(currentEvulateId, result);
                    }
                }
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.structuredTemplateBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the structured template body.
     */
    visitStructuredTemplateBody(ctx) {
        const result = {};
        const typeName = ctx.structuredBodyNameLine().STRUCTURE_NAME().text;
        result[Evaluator.LGType] = typeName;
        const bodys = ctx.structuredBodyContentLine();
        for (const body of bodys) {
            const isKVPairBody = body.keyValueStructureLine() !== undefined;
            if (isKVPairBody) {
                const property = body.keyValueStructureLine().STRUCTURE_IDENTIFIER().text.toLowerCase();
                const value = this.visitStructureValue(body.keyValueStructureLine());
                result[property] = value;
            }
            else {
                const propertyObject = this.evalExpression(body.expressionInStructure().text, body.expressionInStructure(), body.text);
                // Full reference to another structured template is limited to the structured template with same type
                if (propertyObject &&
                    typeof propertyObject === 'object' &&
                    Evaluator.LGType in propertyObject &&
                    propertyObject[Evaluator.LGType].toString() === typeName) {
                    for (const key of Object.keys(propertyObject)) {
                        if (propertyObject.hasOwnProperty(key) && !(key in result)) {
                            result[key] = propertyObject[key];
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * @private
     */
    visitStructureValue(ctx) {
        const values = ctx.keyValueStructureValue();
        const result = [];
        for (const item of values) {
            if (templateExtensions_1.TemplateExtensions.isPureExpression(item)) {
                result.push(this.evalExpression(item.expressionInStructure(0).text, item.expressionInStructure(0), ctx.text));
            }
            else {
                let itemStringResult = '';
                for (const child of item.children) {
                    if (child instanceof lp.ExpressionInStructureContext) {
                        const errorPrefix = `Property '` + ctx.STRUCTURE_IDENTIFIER().text + `':`;
                        itemStringResult += this.evalExpression(child.text, child, ctx.text, errorPrefix);
                    }
                    else {
                        const node = child;
                        switch (node.symbol.type) {
                            case lp.LGTemplateParser.ESCAPE_CHARACTER_IN_STRUCTURE_BODY:
                                itemStringResult += templateExtensions_1.TemplateExtensions.evalEscape(node.text.replace(/\\\|/g, '|'));
                                break;
                            default:
                                itemStringResult += node.text;
                                break;
                        }
                    }
                }
                result.push(itemStringResult.trim());
            }
        }
        return result.length === 1 ? result[0] : result;
    }
    /**
     * Visit a parse tree produced by the normalBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal body.
     */
    visitNormalBody(ctx) {
        return this.visit(ctx.normalTemplateBody());
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal template body.
     */
    visitNormalTemplateBody(ctx) {
        const normalTemplateStrs = ctx.templateString();
        const randomNumber = adaptive_expressions_1.Extensions.randomNext(this.currentTarget().scope, 0, normalTemplateStrs.length);
        return this.visit(normalTemplateStrs[randomNumber].normalTemplateString());
    }
    /**
     * Visit a parse tree produced by the ifElseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     */
    visitIfElseBody(ctx) {
        const ifRules = ctx.ifElseTemplateBody().ifConditionRule();
        for (const ifRule of ifRules) {
            if (this.evalCondition(ifRule.ifCondition()) && ifRule.normalTemplateBody() !== undefined) {
                return this.visit(ifRule.normalTemplateBody());
            }
        }
        return undefined;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateString.
     * @param ctx The parse tree.
     * @returns The string result of visiting the normal template string.
     */
    visitNormalTemplateString(ctx) {
        const prefixErrorMsg = templateExtensions_1.TemplateExtensions.getPrefixErrorMessage(ctx);
        const result = [];
        for (const child of ctx.children) {
            if (child instanceof lp.ExpressionContext) {
                result.push(this.evalExpression(child.text, child, ctx.text, prefixErrorMsg));
            }
            else {
                const node = child;
                switch (node.symbol.type) {
                    case lp.LGTemplateParser.MULTILINE_SUFFIX:
                    case lp.LGTemplateParser.MULTILINE_PREFIX:
                    case lp.LGTemplateParser.DASH:
                        break;
                    case lp.LGTemplateParser.ESCAPE_CHARACTER:
                        result.push(templateExtensions_1.TemplateExtensions.evalEscape(node.text));
                        break;
                    default: {
                        result.push(node.text);
                        break;
                    }
                }
            }
        }
        if (result.length === 1 && !(typeof result[0] === 'string')) {
            return result[0];
        }
        return result
            .map((u) => {
            if (typeof u === 'string') {
                return u;
            }
            else {
                return JSON.stringify(u);
            }
        })
            .join('');
    }
    /**
     * Constructs the scope for mapping the values of arguments to the parameters of the template.
     * Throws errors if certain errors detected [TemplateErrors](xref:botbuilder-lg.TemplateErrors).
     * @param inputTemplateName Template name to evaluate.
     * @param args Arguments to map to the template parameters.
     * @param allTemplates All templates.
     * @returns The current scope if the number of arguments is 0, otherwise, returns a [CustomizedMemory](xref:botbuilder-lg.CustomizedMemory)
     * with the mapping of the parameter name to the argument value added to the scope.
     */
    constructScope(inputTemplateName, args, allTemplates) {
        const templateName = this.parseTemplateName(inputTemplateName).pureTemplateName;
        const templateMap = lodash_1.keyBy(allTemplates, (t) => t.name);
        if (!(templateName in templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const parameters = templateMap[templateName].parameters;
        const currentScope = this.currentTarget().scope;
        if (args.length === 0) {
            // no args to construct, inherit from current scope
            return currentScope;
        }
        const newScope = {};
        parameters.map((e, i) => (newScope[e] = args[i]));
        const memory = currentScope;
        if (!memory) {
            throw new Error(templateErrors_1.TemplateErrors.invalidMemory);
        }
        return new customizedMemory_1.CustomizedMemory(memory.globalMemory, adaptive_expressions_1.SimpleObjectMemory.wrap(newScope));
    }
    /**
     * Visit a parse tree produced by the switchCaseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The string result of visiting the switch case body.
     */
    visitSwitchCaseBody(ctx) {
        const switchcaseNodes = ctx.switchCaseTemplateBody().switchCaseRule();
        const length = switchcaseNodes.length;
        const switchNode = switchcaseNodes[0];
        const switchExprs = switchNode.switchCaseStat().expression();
        const switchErrorPrefix = `Switch '` + switchExprs[0].text + `': `;
        const switchExprResult = this.evalExpression(switchExprs[0].text, switchExprs[0], switchcaseNodes[0].switchCaseStat().text, switchErrorPrefix);
        let idx = 0;
        for (const caseNode of switchcaseNodes) {
            if (idx === 0) {
                idx++;
                continue; //skip the first node which is a switch statement
            }
            if (idx === length - 1 && caseNode.switchCaseStat().DEFAULT() !== undefined) {
                const defaultBody = caseNode.normalTemplateBody();
                if (defaultBody !== undefined) {
                    return this.visit(defaultBody);
                }
                else {
                    return undefined;
                }
            }
            const caseExprs = caseNode.switchCaseStat().expression();
            const caseErrorPrefix = `Case '` + caseExprs[0].text + `': `;
            const caseExprResult = this.evalExpression(caseExprs[0].text, caseExprs[0], caseNode.switchCaseStat().text, caseErrorPrefix);
            if (adaptive_expressions_1.FunctionUtils.commonEquals(switchExprResult, caseExprResult)) {
                return this.visit(caseNode.normalTemplateBody());
            }
            idx++;
        }
        return undefined;
    }
    /**
     * Replaces an expression contained in text.
     * @param exp Expression Text.
     * @param regex Regex to select the text to replace.
     */
    wrappedEvalTextContainsExpression(exp, regex) {
        return exp
            .split('')
            .reverse()
            .join('')
            .replace(regex, (sub) => this.evalExpression(sub.split('').reverse().join('')).toString().split('').reverse().join(''))
            .split('')
            .reverse()
            .join('');
    }
    /**
     * Gets the default value returned by visitor methods.
     * @returns Empty string.
     */
    defaultResult() {
        return '';
    }
    /**
     * Concatenates two error messages.
     * @param firstError First error message to concatenate.
     * @param secondError Second error message to concatenate.
     * @returns The concatenated error messages.
     */
    static concatErrorMsg(firstError, secondError) {
        let errorMsg;
        if (!firstError) {
            errorMsg = secondError;
        }
        else if (!secondError) {
            errorMsg = firstError;
        }
        else {
            errorMsg = firstError + ' ' + secondError;
        }
        return errorMsg;
    }
    /**
     * Checks an expression result and throws the corresponding error.
     * @param exp Expression text.
     * @param error Error message.
     * @param result Result.
     * @param templateName Template name.
     * @param inlineContent Optional. In line content.
     * @param errorPrefix Optional. Error prefix.
     */
    static checkExpressionResult(exp, error, result, templateName, inlineContent = '', errorPrefix = '') {
        let errorMsg = '';
        let childErrorMsg = '';
        if (error) {
            childErrorMsg = Evaluator.concatErrorMsg(childErrorMsg, error);
        }
        else if (!result) {
            childErrorMsg = Evaluator.concatErrorMsg(childErrorMsg, templateErrors_1.TemplateErrors.nullExpression(exp));
        }
        if (inlineContent && inlineContent.trim() !== '') {
            errorMsg = Evaluator.concatErrorMsg(errorMsg, templateErrors_1.TemplateErrors.errorExpression(inlineContent, templateName, errorPrefix));
        }
        throw new Error(Evaluator.concatErrorMsg(childErrorMsg, errorMsg));
    }
    /**
     * @private
     */
    currentTarget() {
        // just don't want to write evaluationTargetStack.Peek() everywhere
        return this.evaluationTargetStack[this.evaluationTargetStack.length - 1];
    }
    /**
     * @private
     */
    evalCondition(condition) {
        const expression = condition.expression()[0]; // Here ts is diff with C#, C# use condition.EXPRESSION(0) == null
        // to judge ELSE condition. But in ts lib this action would throw
        // Error
        if (!expression) {
            return true; // no expression means it's else
        }
        if (this.evalExpressionInCondition(expression, condition.text, `Condition '` + expression.text + `':`)) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    evalExpressionInCondition(expressionContext, contentLine, errorPrefix = '') {
        const exp = templateExtensions_1.TemplateExtensions.trimExpression(expressionContext.text);
        const { value: result, error: error } = this.evalByAdaptiveExpression(exp, this.currentTarget().scope);
        if (this.lgOptions.strictMode && (error || !result)) {
            const templateName = this.currentTarget().templateName;
            if (this.evaluationTargetStack.length > 0) {
                this.evaluationTargetStack.pop();
            }
            Evaluator.checkExpressionResult(exp, error, result, templateName, contentLine, errorPrefix);
        }
        else if (error || !result) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    evalExpression(exp, expressionContext, inlineContent = '', errorPrefix = '') {
        exp = templateExtensions_1.TemplateExtensions.trimExpression(exp);
        const { value: result, error: error } = this.evalByAdaptiveExpression(exp, this.currentTarget().scope);
        if (error || (result === undefined && this.lgOptions.strictMode)) {
            const templateName = this.currentTarget().templateName;
            if (this.evaluationTargetStack.length > 0) {
                this.evaluationTargetStack.pop();
            }
            Evaluator.checkExpressionResult(exp, error, result, templateName, inlineContent, errorPrefix);
        }
        return result;
    }
    /**
     * @private
     */
    evalByAdaptiveExpression(exp, scope) {
        const parse = this.expressionParser.parse(exp);
        const opt = new adaptive_expressions_1.Options();
        opt.nullSubstitution = this.lgOptions.nullSubstitution;
        opt.locale = this.lgOptions.locale;
        return parse.tryEvaluate(scope, opt);
    }
    /**
     * @private
     */
    getResourcePath(filePath) {
        let resourcePath;
        if (path.isAbsolute(filePath)) {
            resourcePath = filePath;
        }
        else {
            // relative path is not support in broswer environment
            const inBrowser = typeof window !== 'undefined';
            if (inBrowser) {
                throw new Error('relative path is not support in browser.');
            }
            const template = this.templateMap[this.currentTarget().templateName];
            const sourcePath = templateExtensions_1.TemplateExtensions.normalizePath(template.sourceRange.source);
            let baseFolder = __dirname;
            if (path.isAbsolute(sourcePath)) {
                baseFolder = path.dirname(sourcePath);
            }
            resourcePath = path.join(baseFolder, filePath);
        }
        return resourcePath;
    }
    /**
     * @private
     */
    checkTemplateReference(templateName, children) {
        if (!(templateName in this.templateMap)) {
            throw new Error(templateErrors_1.TemplateErrors.templateNotExist(templateName));
        }
        const expectedArgsCount = this.templateMap[templateName].parameters.length;
        const actualArgsCount = children.length;
        if (actualArgsCount !== 0 && expectedArgsCount !== actualArgsCount) {
            throw new Error(templateErrors_1.TemplateErrors.argumentMismatch(templateName, expectedArgsCount, actualArgsCount));
        }
    }
    /**
     * @private
     */
    parseTemplateName(templateName) {
        if (!templateName) {
            throw new Error('template name is empty.');
        }
        if (templateName.endsWith(Evaluator.ReExecuteSuffix)) {
            return {
                reExecute: true,
                pureTemplateName: templateName.substr(0, templateName.length - Evaluator.ReExecuteSuffix.length),
            };
        }
        else {
            return { reExecute: false, pureTemplateName: templateName };
        }
    }
}
Evaluator.LGType = 'lgType';
Evaluator.activityAttachmentFunctionName = 'ActivityAttachment';
Evaluator.fromFileFunctionName = 'fromFile';
Evaluator.templateFunctionName = 'template';
Evaluator.isTemplateFunctionName = 'isTemplate';
Evaluator.expandTextFunctionName = 'expandText';
Evaluator.ReExecuteSuffix = '!';
exports.Evaluator = Evaluator;
//# sourceMappingURL=evaluator.js.map