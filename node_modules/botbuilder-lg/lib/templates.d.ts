/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { Template } from './template';
import { TemplateImport } from './templateImport';
import { Diagnostic } from './diagnostic';
import { ExpressionParser } from 'adaptive-expressions';
import { ImportResolverDelegate } from './templatesParser';
import { AnalyzerResult } from './analyzerResult';
import { EvaluationOptions } from './evaluationOptions';
import { LGResource } from './lgResource';
/**
 * LG entrance, including properties that LG file has, and evaluate functions.
 */
export declare class Templates implements Iterable<Template> {
    /**
     * Temp Template ID for inline content.
     */
    static readonly inlineTemplateIdPrefix: string;
    private readonly newLineRegex;
    private readonly newLine;
    private readonly namespaceKey;
    private readonly exportsKey;
    private items;
    /**
     * import elements that this LG file contains directly.
     */
    imports: TemplateImport[];
    /**
     * diagnostics.
     */
    diagnostics: Diagnostic[];
    /**
     * all references that this LG file has from Imports
     * otice: reference includs all child imports from the lg file,
     * not only the children belong to this lgfile directly.
     * so, reference count may >= imports count.
     */
    references: Templates[];
    /**
     * LG content.
     */
    content: string;
    /**
     * Id of the lg resource.
     */
    id: string;
    /**
     * expression parser.
     */
    expressionParser: ExpressionParser;
    /**
     * Source of the lg resource. Full path for lg file.
     */
    source: string;
    /**
     * Delegate for resolving resource id of imported lg file.
     */
    importResolver: ImportResolverDelegate;
    /**
     * LG file options.
     */
    options: string[];
    /**
     * Map from import alias to templates.
     */
    namedReferences: Record<string, Templates>;
    /**
     * Creates a new instance of the [Templates](xref:botbuilder-lg.Templates) class.
     * @param items Optional. List of [Template](xref:botbuilder-lg.Template) instances.
     * @param imports Optional. List of [TemplateImport](xref:botbuilder-lg.TemplateImport) instances.
     * @param diagnostics Optional. List of [Diagnostic](xref:botbuilder-lg.Diagnostic) instances.
     * @param references Optional. List of [Templates](xref:botbuilder-lg.Templates) instances.
     * @param content Optional. Content of the current Templates instance.
     * @param id Optional. Id of the current Templates instance.
     * @param expressionParser Optional. [ExpressionParser](xref:adaptive-expressions.ExpressionParser) to parse the expressions in the content.
     * @param importResolverDelegate Optional. Resolver to resolve LG import id to template text.
     * @param options Optional. List of strings representing the options during evaluation of the templates.
     * @param source Optional. Templates source.
     * @param namedReferences Optional. eferences that imported with the "as" syntaxï¼Œfor example: [import](path.lg) as myAlias.
     */
    constructor(items?: Template[], imports?: TemplateImport[], diagnostics?: Diagnostic[], references?: Templates[], content?: string, id?: string, expressionParser?: ExpressionParser, importResolverDelegate?: ImportResolverDelegate, options?: string[], source?: string, namedReferences?: Record<string, Templates>);
    /**
     * Returns a new iterator for the template collection.
     */
    [Symbol.iterator](): Iterator<Template>;
    /**
     * Returns a reference to the internal list of collection templates.
     */
    toArray(): Template[];
    /**
     * Appends 1 or more templates to the collection.
     * @param args List of templates to add.
     */
    push(...args: Template[]): void;
    /**
     * A value indicating whether the options when evaluation LG templates.
     */
    readonly lgOptions: EvaluationOptions;
    /**
     * A string value represents the namespace to register for current LG file.
     */
    readonly namespace: string;
    /**
     * All templates from current lg file and reference lg files.
     */
    readonly allTemplates: Template[];
    /**
     * All diagnostics from current lg file and reference lg files.
     */
    readonly allDiagnostics: Diagnostic[];
    /**
     * parse a file and return LG file.
     * @param filePath LG absolute file path..
     * @param importResolver Resolver to resolve LG import id to template text.
     * @param expressionParser Expression parser for evaluating expressions.
     * @returns New lg file.
     */
    static parseFile(filePath: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    /**
     * Parser to turn lg content into a Templates.
     * @deprecated This method will soon be deprecated. Use ParseResource instead.
     * @param content Text content contains lg templates.
     * @param id Id is the identifier of content. If importResolver is undefined, id must be a full path string.
     * @param importResolver Resolver to resolve LG import id to template text.
     * @param expressionParser Expression parser for evaluating expressions.
     * @returns Entity.
     */
    static parseText(content: string, id?: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    /**
     * Parser to turn lg content into a Templates.
     * @param aresource LG resource.
     * @param importResolver Resolver to resolve LG import id to template text.
     * @param expressionParser Expression parser for evaluating expressions.
     * @returns Entity.
     */
    static parseResource(resource: LGResource, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    /**
     * Evaluate a template with given name and scope.
     * @param templateName Template name to be evaluated.
     * @param scope The state visible in the evaluation.
     * @returns Evaluate result.
     */
    evaluate(templateName: string, scope?: object, opt?: EvaluationOptions): any;
    /**
     * Expand a template with given name and scope.
     * Return all possible responses instead of random one.
     * @param templateName Template name to be evaluated.
     * @param scope The state visible in the evaluation.
     * @returns Expand result.
     */
    expandTemplate(templateName: string, scope?: object, opt?: EvaluationOptions): any[];
    /**
     * Analyze a template to get the static analyzer results including variables and template references.
     * @param templateName Template name to be evaluated.
     * @returns Analyzer result.
     */
    analyzeTemplate(templateName: string): AnalyzerResult;
    /**
     * Use to evaluate an inline template str.
     * @param inlineStr Inline string which will be evaluated.
     * @param scope Scope object or JToken.
     */
    evaluateText(inlineStr: string, scope?: object, opt?: EvaluationOptions): any;
    /**
     * Update a template and return LG file.
     * @param templateName Orignial template name.
     * @param newTemplateName New template name.
     * @param parameters New params.
     * @param templateBody New template body.
     * @returns New lg file.
     */
    updateTemplate(templateName: string, newTemplateName: string, parameters: string[], templateBody: string): Templates;
    /**
     * Add a new template and return LG file.
     * @param templateName New template name.
     * @param parameters New params.
     * @param templateBody New  template body.
     * @returns New lg file.
     */
    addTemplate(templateName: string, parameters: string[], templateBody: string): Templates;
    /**
     * Delete an exist template.
     * @param templateName Which template should delete.
     * @returns Return the new lg file.
     */
    deleteTemplate(templateName: string): Templates;
    /**
     * Returns a string representation of a [Templates](xref:botbuilder-lg.Templates) content.
     * @returns A string representation of a [Templates](xref:botbuilder-lg.Templates) content.
     */
    toString(): string;
    /**
     * @private
     */
    private getRandomTemplateId;
    /**
     * @private
     */
    private appendDiagnosticWithOffset;
    /**
     * @private
     */
    private adjustRangeForUpdateTemplate;
    /**
     * @private
     */
    private adjustRangeForAddTemplate;
    /**
     * @private
     */
    private adjustRangeForDeleteTemplate;
    /**
     * @private
     */
    private clearDiagnostic;
    /**
     * @private
     */
    private replaceRangeContent;
    /**
     * @private
     */
    private convertTemplateBody;
    /**
     * @private
     * Compute LG SourceRange based on content instead of parsed token.
     * */
    private recomputeSourceRange;
    /**
     * @private
     */
    private buildTemplateNameLine;
    /**
     * @private
     */
    private checkErrors;
    /**
     * @private
     */
    private injectToExpressionFunction;
    /**
     * @private
     */
    private extractOptionByKey;
    /**
     * @private
     */
    private extractNamespace;
    /**
     * @private
     */
    private getGlobalFunctionTable;
}
//# sourceMappingURL=templates.d.ts.map