"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable security/detect-object-injection */
/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const tree_1 = require("antlr4ts/tree");
const lodash_1 = require("lodash");
const evaluationTarget_1 = require("./evaluationTarget");
const evaluator_1 = require("./evaluator");
const templateExtensions_1 = require("./templateExtensions");
const analyzerResult_1 = require("./analyzerResult");
/**
 * Analyzer engine. To get the static analyzer results.
 */
class Analyzer extends tree_1.AbstractParseTreeVisitor {
    /**
     * Creates a new instance of the [Analyzer](xref:botbuilder-lg.Analyzer) class.
     * @param templates Templates.
     * @param opt Options for LG.
     */
    constructor(templates, opt) {
        super();
        this.evalutationTargetStack = [];
        this.templates = templates;
        this.templateMap = lodash_1.keyBy(templates.allTemplates, (t) => t.name);
        // create an evaluator to leverage its customized function look up for checking
        const evaluator = new evaluator_1.Evaluator(this.templates, opt);
        this._expressionParser = evaluator.expressionParser;
    }
    /**
     * Analyze a template to get the static analyzer results.
     * @param templateName Template name.
     * @returns Analyze result including variables and template references.
     */
    analyzeTemplate(templateName) {
        if (!(templateName in this.templateMap) ||
            this.evalutationTargetStack.find((u) => u.templateName === templateName) !==
                undefined) {
            return new analyzerResult_1.AnalyzerResult();
        }
        // Using a stack to track the evalution trace
        this.evalutationTargetStack.push(new evaluationTarget_1.EvaluationTarget(templateName, undefined));
        // we don't exclude paratemters any more
        // because given we don't track down for templates have parameters
        // the only scenario that we are still analyzing an parameterized template is
        // this template is root template to anaylze, in this we also don't have exclude parameters
        const dependencies = this.visit(this.templateMap[templateName].templateBodyParseTree);
        this.evalutationTargetStack.pop();
        return dependencies;
    }
    /**
     * Visit a parse tree produced by the normalBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitNormalBody(ctx) {
        return this.visit(ctx.normalTemplateBody());
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateBody.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitNormalTemplateBody(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        for (const templateStr of ctx.templateString()) {
            result.union(this.visit(templateStr.normalTemplateString()));
        }
        return result;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.structuredTemplateBody.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitStructuredTemplateBody(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        const bodys = ctx.structuredBodyContentLine();
        for (const body of bodys) {
            const isKVPairBody = body.keyValueStructureLine() !== undefined;
            if (isKVPairBody) {
                result.union(this.visitStructureValue(body.keyValueStructureLine()));
            }
            else {
                result.union(this.analyzeExpression(body.expressionInStructure().text));
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.structuredValue.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitStructureValue(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        const values = ctx.keyValueStructureValue();
        for (const item of values) {
            if (templateExtensions_1.TemplateExtensions.isPureExpression(item)) {
                result.union(this.analyzeExpression(item.expressionInStructure(0).text));
            }
            else {
                const exprs = item.expressionInStructure();
                for (const expr of exprs) {
                    result.union(this.analyzeExpression(expr.text));
                }
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the ifElseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitIfElseBody(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        const ifRules = ctx.ifElseTemplateBody().ifConditionRule();
        for (const ifRule of ifRules) {
            const expressions = ifRule.ifCondition().expression();
            if (expressions !== undefined && expressions.length > 0) {
                result.union(this.analyzeExpression(expressions[0].text));
            }
            if (ifRule.normalTemplateBody() !== undefined) {
                result.union(this.visit(ifRule.normalTemplateBody()));
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by the switchCaseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitSwitchCaseBody(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        const switchCaseNodes = ctx.switchCaseTemplateBody().switchCaseRule();
        for (const iterNode of switchCaseNodes) {
            const expressions = iterNode.switchCaseStat().expression();
            if (expressions.length > 0) {
                result.union(this.analyzeExpression(expressions[0].text));
            }
            if (iterNode.normalTemplateBody()) {
                result.union(this.visit(iterNode.normalTemplateBody()));
            }
        }
        return result;
    }
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateString.
     * @param ctx The parse tree.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    visitNormalTemplateString(ctx) {
        const result = new analyzerResult_1.AnalyzerResult();
        for (const expression of ctx.expression()) {
            result.union(this.analyzeExpression(expression.text));
        }
        return result;
    }
    /**
     * Gets the default value returned by visitor methods.
     * @returns An instance of the AnalyzerResult class.
     * @returns The [AnalyzerResult](xref:botbuilder-lg.AnalyzerResult) instance.
     */
    defaultResult() {
        return new analyzerResult_1.AnalyzerResult();
    }
    /**
     * @private
     */
    analyzeExpressionDirectly(exp) {
        const result = new analyzerResult_1.AnalyzerResult();
        if (exp.type in this.templateMap) {
            const templateName = exp.type;
            result.union(new analyzerResult_1.AnalyzerResult([], [templateName]));
            if (this.templateMap[templateName].parameters === undefined ||
                this.templateMap[templateName].parameters.length === 0) {
                result.union(this.analyzeTemplate(templateName));
            }
            else if (!result.TemplateReferences.includes(templateName)) {
                // if template has params, just get the templateref without variables.
                result.union(new analyzerResult_1.AnalyzerResult([], this.analyzeTemplate(templateName).TemplateReferences));
            }
        }
        if (exp.children !== undefined) {
            exp.children.forEach((e) => result.union(this.analyzeExpressionDirectly(e)));
        }
        return result;
    }
    /**
     * @private
     */
    analyzeExpression(exp) {
        const result = new analyzerResult_1.AnalyzerResult();
        exp = templateExtensions_1.TemplateExtensions.trimExpression(exp);
        const parsed = this._expressionParser.parse(exp);
        const references = parsed.references();
        result.union(new analyzerResult_1.AnalyzerResult(references.slice(), []));
        result.union(this.analyzeExpressionDirectly(parsed));
        return result;
    }
}
exports.Analyzer = Analyzer;
//# sourceMappingURL=analyzer.js.map