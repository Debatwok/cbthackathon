/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { AbstractParseTreeVisitor } from 'antlr4ts/tree';
import { MemoryInterface } from 'adaptive-expressions';
import * as lp from './generated/LGTemplateParser';
import { LGTemplateParserVisitor } from './generated/LGTemplateParserVisitor';
import { Template } from './template';
import { EvaluationOptions } from './evaluationOptions';
import { Templates } from './templates';
/**
 * LG template expander.
 */
export declare class Expander extends AbstractParseTreeVisitor<unknown[]> implements LGTemplateParserVisitor<unknown[]> {
    /**
     * Templates.
     */
    readonly templates: Templates;
    /**
     * Expander expression parser
     */
    private readonly expanderExpressionParser;
    /**
     * Evaluator expression parser
     */
    private readonly evaluatorExpressionParser;
    /**
     * TemplateMap.
     */
    readonly templateMap: {
        [name: string]: Template;
    };
    private readonly evaluationTargetStack;
    private readonly lgOptions;
    /**
     * Creates a new instance of the Expander class.
     * @param templates Template list.
     * @param expressionParser Given expression parser.
     * @param opt Options for LG.
     */
    constructor(templates: Templates, opt?: EvaluationOptions);
    /**
     * Expand the results of a template with given name and scope.
     * @param templateName Given template name.
     * @param scope Given scope.
     * @returns All possiable results.
     */
    expandTemplate(templateName: string, scope: unknown): unknown[];
    /**
     * Visit a parse tree produced by the normalBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal body.
     */
    visitNormalBody(ctx: lp.NormalBodyContext): unknown[];
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the normal template body.
     */
    visitNormalTemplateBody(ctx: lp.NormalTemplateBodyContext): unknown[];
    /**
     * Visit a parse tree produced by the ifElseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     */
    visitIfElseBody(ctx: lp.IfElseBodyContext): unknown[];
    /**
     * Visit a parse tree produced by LGTemplateParser.structuredBody.
     * @param ctx The parse tree.
     * @returns The result of visiting the structured body.
     */
    visitStructuredBody(ctx: lp.StructuredBodyContext): unknown[];
    /**
     * @private
     */
    private visitStructureValue;
    /**
     * Visit a parse tree produced by the switchCaseBody labeled alternative in LGTemplateParser.body.
     * @param ctx The parse tree.
     * @returns The result of visiting the switch case body.
     */
    visitSwitchCaseBody(ctx: lp.SwitchCaseBodyContext): unknown[];
    /**
     * Visit a parse tree produced by LGTemplateParser.normalTemplateString.
     * @param ctx The parse tree.
     */
    visitNormalTemplateString(ctx: lp.NormalTemplateStringContext): unknown[];
    /**
     * Constructs the scope for mapping the values of arguments to the parameters of the template.
     * @param templateName The template name to evaluate.
     * @param args Arguments to map to the template parameters.
     * @param allTemplates All templates.
     * @returns The current scope if the number of arguments is 0, otherwise, returns a CustomizedMemory
     * with the mapping of the parameter name to the argument value added to the scope.
     */
    constructScope(inputTemplateName: string, args: unknown[], allTemplates: Template[]): MemoryInterface;
    /**
     * Gets the default value returned by visitor methods.
     * @returns Empty string array.
     */
    protected defaultResult(): string[];
    /**
     * @private
     */
    private currentTarget;
    /**
     * @private
     */
    private evalCondition;
    /**
     * @private
     */
    private evalExpressionInCondition;
    /**
     * @private
     */
    private evalExpression;
    /**
     * @private
     */
    private evalByAdaptiveExpression;
    /**
     * @private
     */
    private stringArrayConcat;
    private stringConcat;
    private readonly customizedEvaluatorLookup;
    private readonly evaluateWithTemplates;
    private readonly templateEvaluator;
    private readonly templateExpander;
    /**
     * @private
     */
    private reconstructExpression;
    private readonly isTemplate;
    private readonly fromFile;
    private readonly expandText;
    /**
     * @private
     */
    private getResourcePath;
    private readonly activityAttachment;
    private readonly templateFunction;
    private readonly validateTemplateFunction;
    /**
     * @private
     */
    private checkTemplateReference;
    private readonly validTemplateReference;
    /**
     * @private
     */
    private parseTemplateName;
}
//# sourceMappingURL=expander.d.ts.map