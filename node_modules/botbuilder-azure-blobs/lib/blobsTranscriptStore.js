"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobsTranscriptStore = void 0;
const z = __importStar(require("zod"));
const get_stream_1 = __importDefault(require("get-stream"));
const p_map_1 = __importDefault(require("p-map"));
const maybeCast_1 = require("botbuilder-stdlib/lib/maybeCast");
const sanitizeBlobKey_1 = require("./sanitizeBlobKey");
const storage_blob_1 = require("@azure/storage-blob");
// Formats a timestamp in a way that is consistent with the C# SDK
function formatTicks(timestamp) {
    const epochTicks = 621355968000000000; // the number of .net ticks at the unix epoch
    const ticksPerMillisecond = 10000; // there are 10000 .net ticks per millisecond
    const ticks = epochTicks + timestamp.getTime() * ticksPerMillisecond;
    return ticks.toString(16);
}
// Formats a channelId as a blob prefix
function getChannelPrefix(channelId) {
    return sanitizeBlobKey_1.sanitizeBlobKey(`${channelId}/`);
}
// Formats a channelId and conversationId as a blob prefix
function getConversationPrefix(channelId, conversationId) {
    return sanitizeBlobKey_1.sanitizeBlobKey(`${channelId}/${conversationId}`);
}
// Formats an activity as a blob key
function getBlobKey(activity) {
    const { timestamp } = z
        .object({ timestamp: z.instanceof(Date) })
        .nonstrict()
        .parse(activity);
    return sanitizeBlobKey_1.sanitizeBlobKey([activity.channelId, activity.conversation.id, `${formatTicks(timestamp)}-${activity.id}.json`].join('/'));
}
// Max number of results returned in a single Azure API call
const MAX_PAGE_SIZE = 20;
/**
 * BlobsTranscriptStore is a [TranscriptStore](xref:botbuilder-core.TranscriptStore) that persists
 * transcripts in Azure Blob Storage
 *
 * @summary
 * Each activity is stored as JSON blob with a key of
 * `container/{channelId]/{conversationId}/{Timestamp.ticks}-{activity.id}.json`.
 */
class BlobsTranscriptStore {
    /**
     * Constructs a BlobsTranscriptStore instance.
     *
     * @param {string} connectionString Azure Blob Storage connection string
     * @param {string} containerName Azure Blob Storage container name
     * @param {BlobsTranscriptStoreOptions} options Other options for BlobsTranscriptStore
     */
    constructor(connectionString, containerName, options) {
        this._concurrency = Infinity;
        z.object({ connectionString: z.string(), containerName: z.string() }).parse({
            connectionString,
            containerName,
        });
        this._containerClient = new storage_blob_1.ContainerClient(connectionString, containerName, options === null || options === void 0 ? void 0 : options.storagePipelineOptions);
        // At most one promise at a time to be friendly to local emulator users
        if (connectionString.trim() === 'UseDevelopmentStorage=true;') {
            this._concurrency = 1;
        }
    }
    // Protects against JSON.stringify cycles
    toJSON() {
        return { name: 'BlobsTranscriptStore' };
    }
    _initialize() {
        if (!this._initializePromise) {
            this._initializePromise = this._containerClient.createIfNotExists();
        }
        return this._initializePromise;
    }
    /**
     * Get activities for a conversation (aka the transcript).
     *
     * @param {string} channelId channelId
     * @param {string} conversationId conversationId
     * @param {string} continuationToken continuation token to page through results
     * @param {Date} startDate earliest time to include in results
     * @returns {Promise<PagedResult<Activity>>} Promise that resolves to a
     * [PagedResult](xref:botbuilder-core.PagedResult) of [Activity](xref:botbuilder-core.Activity) items
     */
    getTranscriptActivities(channelId, conversationId, continuationToken, startDate) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            z.object({ channelId: z.string(), conversationId: z.string() }).parse({ channelId, conversationId });
            yield this._initialize();
            const iter = this._containerClient
                .listBlobsByHierarchy('/', {
                prefix: getConversationPrefix(channelId, conversationId),
            })
                .byPage({ continuationToken, maxPageSize: MAX_PAGE_SIZE });
            let page = yield iter.next();
            while (!page.done) {
                // Note: azure library does not properly type iterator result, hence the need to cast
                const response = maybeCast_1.maybeCast((_a = page === null || page === void 0 ? void 0 : page.value) !== null && _a !== void 0 ? _a : {});
                const blobItems = (_c = (_b = response === null || response === void 0 ? void 0 : response.segment) === null || _b === void 0 ? void 0 : _b.blobItems) !== null && _c !== void 0 ? _c : [];
                // Locate first index of results to slice from. If we have a start date, we want to return
                // activities after that start date. Otherwise we can simply return all activities in this page.
                const fromIdx = startDate != null
                    ? blobItems.findIndex((blobItem) => { var _a; return ((_a = blobItem === null || blobItem === void 0 ? void 0 : blobItem.metadata) === null || _a === void 0 ? void 0 : _a.timestamp) && new Date(blobItem.metadata.timestamp) >= startDate; })
                    : 0;
                if (fromIdx !== -1) {
                    const activities = yield p_map_1.default(blobItems.slice(fromIdx), (blobItem) => __awaiter(this, void 0, void 0, function* () {
                        const blob = yield this._containerClient.getBlobClient(blobItem.name).download();
                        const { readableStreamBody: stream } = blob;
                        if (!stream) {
                            return null;
                        }
                        const contents = yield get_stream_1.default(stream);
                        const activity = JSON.parse(contents);
                        return Object.assign(Object.assign({}, activity), { timestamp: new Date(activity.timestamp) });
                    }), { concurrency: this._concurrency });
                    return {
                        continuationToken: (_d = response === null || response === void 0 ? void 0 : response.continuationToken) !== null && _d !== void 0 ? _d : '',
                        items: activities.reduce((acc, activity) => (activity ? acc.concat(activity) : acc), []),
                    };
                }
                page = yield iter.next();
            }
            return { continuationToken: '', items: [] };
        });
    }
    /**
     * List conversations in the channelId.
     *
     * @param {string} channelId channelId
     * @param {string} continuationToken continuation token to page through results
     * @returns {Promise<PagedResult<TranscriptInfo>>} Promise that resolves to a
     * [PagedResult](xref:botbuilder-core.PagedResult) of [Activity](xref:botbuilder-core.Activity) items
     */
    listTranscripts(channelId, continuationToken) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            z.object({ channelId: z.string() }).parse({ channelId });
            yield this._initialize();
            const page = yield this._containerClient
                .listBlobsByHierarchy('/', {
                prefix: getChannelPrefix(channelId),
            })
                .byPage({ continuationToken, maxPageSize: MAX_PAGE_SIZE })
                .next();
            // Note: azure library does not properly type iterator result, hence the need to cast
            const response = maybeCast_1.maybeCast((_a = page === null || page === void 0 ? void 0 : page.value) !== null && _a !== void 0 ? _a : {});
            const blobItems = (_c = (_b = response === null || response === void 0 ? void 0 : response.segment) === null || _b === void 0 ? void 0 : _b.blobItems) !== null && _c !== void 0 ? _c : [];
            return {
                continuationToken: (_d = response === null || response === void 0 ? void 0 : response.continuationToken) !== null && _d !== void 0 ? _d : '',
                items: blobItems.map((blobItem) => {
                    var _a;
                    const [, id] = decodeURIComponent(blobItem.name).split('/');
                    const created = ((_a = blobItem.metadata) === null || _a === void 0 ? void 0 : _a.timestamp) ? new Date(blobItem.metadata.timestamp) : new Date();
                    return { channelId, created, id };
                }),
            };
        });
    }
    /**
     * Delete a specific conversation and all of its activities.
     *
     * @param {string} channelId channelId
     * @param {string} conversationId conversationId
     * @returns {Promise<void>} A promise representing the async operation.
     */
    deleteTranscript(channelId, conversationId) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            z.object({ channelId: z.string(), conversationId: z.string() }).parse({ channelId, conversationId });
            yield this._initialize();
            const iter = this._containerClient
                .listBlobsByHierarchy('/', {
                prefix: getConversationPrefix(channelId, conversationId),
            })
                .byPage({
                maxPageSize: MAX_PAGE_SIZE,
            });
            let page = yield iter.next();
            while (!page.done) {
                // Note: azure library does not properly type iterator result, hence the need to cast
                const response = maybeCast_1.maybeCast((_a = page === null || page === void 0 ? void 0 : page.value) !== null && _a !== void 0 ? _a : {});
                const blobItems = (_c = (_b = response === null || response === void 0 ? void 0 : response.segment) === null || _b === void 0 ? void 0 : _b.blobItems) !== null && _c !== void 0 ? _c : [];
                yield p_map_1.default(blobItems, (blobItem) => this._containerClient.deleteBlob(blobItem.name), {
                    concurrency: this._concurrency,
                });
                page = yield iter.next();
            }
        });
    }
    /**
     * Log an activity to the transcript.
     *
     * @param {Activity} activity activity to log
     * @returns {Promise<void>} A promise representing the async operation.
     */
    logActivity(activity) {
        return __awaiter(this, void 0, void 0, function* () {
            z.object({ activity: z.record(z.unknown()) }).parse({ activity });
            yield this._initialize();
            const blob = this._containerClient.getBlockBlobClient(getBlobKey(activity));
            const serialized = JSON.stringify(activity);
            const metadata = {
                FromId: activity.from.id,
                RecipientId: activity.recipient.id,
            };
            if (activity.id) {
                metadata.Id = activity.id;
            }
            if (activity.timestamp) {
                metadata.Timestamp = activity.timestamp.toJSON();
            }
            yield blob.upload(serialized, serialized.length, { metadata });
        });
    }
}
exports.BlobsTranscriptStore = BlobsTranscriptStore;
//# sourceMappingURL=blobsTranscriptStore.js.map