"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
const z = __importStar(require("zod"));
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const nconf_1 = require("nconf");
/**
 * Configuration implements the [IConfiguration](xref:botbuilder-dialogs-adaptive-runtime-core.IConfiguration)
 * interface and adds helper methods for setting values, layering sources, and getting type checked values.
 */
class Configuration {
    constructor() {
        this.prefix = [];
        this.provider = new nconf_1.Provider().use('memory');
    }
    /**
     * Bind a path to a Configuration instance such that calls to get or set will
     * automatically include the bound path as a prefix.
     *
     * @param path path to bind to new Configuration instance
     * @returns configuration instance with `path` bound as a prefix
     */
    bind(path) {
        const configuration = new Configuration();
        configuration.prefix = this.prefix.concat(path);
        configuration.provider = this.provider;
        return configuration;
    }
    key(path) {
        return this.prefix.concat(path).join(':');
    }
    /**
     * Get a value by path.
     *
     * @param path path to value
     * @returns the value, or undefined
     */
    get(path) {
        // Note: empty path should yield the entire configuration
        if (!(path === null || path === void 0 ? void 0 : path.length)) {
            return this.provider.get();
        }
        return this.provider.get(this.key(path));
    }
    /**
     * Set a value by path.
     *
     * @param path path to value
     * @param value value to set
     */
    set(path, value) {
        this.provider.set(this.key(path), value);
    }
    /**
     * Load process.arguments as a configuration source.
     *
     * @param argv arguments to parse, defaults to `process.argv`
     * @returns this for chaining
     */
    argv(argv = process.argv.slice(2)) {
        this.provider.argv({
            argv: yargs_parser_1.default(argv, {
                configuration: {
                    'parse-numbers': false,
                },
            }),
        });
        return this;
    }
    /**
     * Load environment variables as a configuration source.
     *
     * @param separator value used to indicate nesting
     * @returns this for chaining
     */
    env(separator = '__') {
        this.provider.env(separator);
        return this;
    }
    /**
     * Load a file as a configuration source.
     *
     * @param name file name
     * @param override optional flag that ensures this file takes precedence over other files
     * @returns this for chaining
     */
    file(name, override = false) {
        var _a;
        this.provider.file(name, name);
        // If we are given a key to override, we need to reach into the nconf provider and rearrange things.
        // The nconf provider maintains an object that maps names to stores. When looking up a key, nconf iterates
        // through the stores in insertion order and returns the first value it finds. This is not ideal because,
        // in order to rearrange stores, we have to essentially reconstruct the object so the insertion order is
        // correct. So this code does that.
        if (override) {
            // Construct list of entries in current insertion order
            const stores = (_a = this.provider.stores) !== null && _a !== void 0 ? _a : {};
            const entries = Object.entries(stores);
            // Locate store to override, if it exists
            const index = entries.findIndex(([, store]) => store.type === 'file');
            // If store exists, we need to remove the store we just added, splice it into entries, and then reduce
            // it back into an object.
            if (index !== -1) {
                // insert this store before the store to override
                entries.splice(index, 0, [name, stores[name]]);
                // slice this store from end of list, then reduce back into object
                this.provider.stores = entries
                    .slice(0, entries.length - 1)
                    .reduce((acc, [key, value]) => (Object.assign(Object.assign({}, acc), { [key]: value })), {});
            }
        }
        return this;
    }
    /**
     * Get a boolean value from config
     *
     * @param path path to boolean value
     * @returns true or false depending on flag
     */
    bool(path) {
        return this.type(path, z.boolean()) === true;
    }
    /**
     * Get a string value from config
     *
     * @param path path to string value
     * @returns the string or undefined
     */
    string(path) {
        return this.type(path, z.string());
    }
    /**
     * Get a typed value from config
     *
     * @param path path to value
     * @param t zod type to use for type checking
     * @returns the value, or undefined
     */
    type(path, t) {
        try {
            return t.optional().parse(this.get(path));
        }
        catch (err) {
            if (z.instanceof(z.ZodError).check(err)) {
                err.errors.forEach((error) => (error.path = [...this.prefix, ...path, ...error.path]));
            }
            throw err;
        }
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map