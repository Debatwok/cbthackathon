"use strict";
/**
 * @module botbuilder-azure
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosDbStorage = void 0;
const semaphore = require("semaphore");
const documentdb_1 = require("documentdb");
const cosmosDbKeyEscape_1 = require("./cosmosDbKeyEscape");
const _semaphore = semaphore(1);
// @types/documentdb does not have DocumentBase definition
const DocumentBase = require('documentdb').DocumentBase; // tslint:disable-line no-require-imports no-var-requires
/**
 * Middleware that implements a CosmosDB based storage provider for a bot.
 *
 * @deprecated Please use CosmosDbPartitionedStorage instead.
 *
 * @remarks
 * The `connectionPolicyConfigurator` handler can be used to further customize the connection to
 * CosmosDB (Connection mode, retry options, timeouts). More information at
 * http://azure.github.io/azure-documentdb-node/global.html#ConnectionPolicy
 */
class CosmosDbStorage {
    /**
     * Creates a new CosmosDbStorage instance.
     *
     * @param settings Setting to configure the provider.
     * @param connectionPolicyConfigurator (Optional) An optional delegate that accepts a ConnectionPolicy for customizing policies. More information at http://azure.github.io/azure-documentdb-node/global.html#ConnectionPolicy
     */
    constructor(settings, connectionPolicyConfigurator = null) {
        if (!settings) {
            throw new Error('The settings parameter is required.');
        }
        if (!settings.serviceEndpoint || settings.serviceEndpoint.trim() === '') {
            throw new Error('The settings service Endpoint is required.');
        }
        if (!settings.authKey || settings.authKey.trim() === '') {
            throw new Error('The settings authKey is required.');
        }
        if (!settings.databaseId || settings.databaseId.trim() === '') {
            throw new Error('The settings dataBase ID is required.');
        }
        if (!settings.collectionId || settings.collectionId.trim() === '') {
            throw new Error('The settings collection ID is required.');
        }
        this.settings = Object.assign({}, settings);
        // Invoke collectionPolicy delegate to further customize settings
        const policy = new DocumentBase.ConnectionPolicy();
        if (connectionPolicyConfigurator && typeof connectionPolicyConfigurator === 'function') {
            connectionPolicyConfigurator(policy);
        }
        this.client = new documentdb_1.DocumentClient(settings.serviceEndpoint, { masterKey: settings.authKey }, policy);
        // Note: hack, however it works with our version
        if (settings.agent) {
            const anyClient = this.client;
            if (anyClient.requestAgent) {
                anyClient.requestAgent = settings.agent;
            }
        }
        this.databaseCreationRequestOption = settings.databaseCreationRequestOptions;
        this.documentCollectionCreationRequestOption = settings.documentCollectionRequestOptions;
    }
    /**
     * Read storage items from storage.
     *
     * @param keys Keys of the items to read from the store.
     * @returns The read items.
     */
    read(keys) {
        if (!keys || keys.length === 0) {
            // No keys passed in, no result to return.
            return Promise.resolve({});
        }
        const parameterSequence = Array.from(Array(keys.length).keys())
            .map((ix) => `@id${ix}`)
            .join(',');
        const parameterValues = keys.map((key, ix) => ({
            name: `@id${ix}`,
            value: cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(key),
        }));
        const querySpec = {
            query: `SELECT c.id, c.realId, c.document, c._etag FROM c WHERE c.id in (${parameterSequence})`,
            parameters: parameterValues,
        };
        let options;
        if (this.settings.partitionKey !== null) {
            options = {
                partitionKey: this.settings.partitionKey,
            };
        }
        return this.ensureCollectionExists().then((collectionLink) => {
            return new Promise((resolve, reject) => {
                const storeItems = {};
                const query = this.client.queryDocuments(collectionLink, querySpec, options);
                const getNext = (q) => {
                    q.nextItem((err, resource) => {
                        if (err) {
                            return reject(err);
                        }
                        if (resource === undefined) {
                            // completed
                            return resolve(storeItems);
                        }
                        // push item
                        storeItems[resource.realId] = resource.document;
                        storeItems[resource.realId].eTag = resource._etag;
                        // visit the remaining results recursively
                        getNext(q);
                    });
                };
                // invoke the function
                getNext(query);
            });
        });
    }
    /**
     * Write storage items to storage.
     *
     * @param changes Items to write to storage, indexed by key.
     */
    write(changes) {
        if (!changes || Object.keys(changes).length === 0) {
            return Promise.resolve();
        }
        return this.ensureCollectionExists().then(() => {
            return Promise.all(Object.keys(changes).map((k) => {
                const changesCopy = Object.assign({}, changes[k]);
                // Remove etag from JSON object that was copied from IStoreItem.
                // The ETag information is updated as an _etag attribute in the document metadata.
                delete changesCopy.eTag;
                const documentChange = {
                    id: cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(k),
                    realId: k,
                    document: changesCopy,
                };
                return new Promise((resolve, reject) => {
                    const handleCallback = (err) => err ? reject(err) : resolve();
                    const eTag = changes[k].eTag;
                    if (!eTag || eTag === '*') {
                        // if new item or * then insert or replace unconditionaly
                        const uri = documentdb_1.UriFactory.createDocumentCollectionUri(this.settings.databaseId, this.settings.collectionId);
                        this.client.upsertDocument(uri, documentChange, { disableAutomaticIdGeneration: true }, handleCallback);
                    }
                    else if (eTag.length > 0) {
                        // if we have an etag, do opt. concurrency replace
                        const uri = documentdb_1.UriFactory.createDocumentUri(this.settings.databaseId, this.settings.collectionId, documentChange.id);
                        const ac = { type: 'IfMatch', condition: eTag };
                        this.client.replaceDocument(uri, documentChange, { accessCondition: ac }, handleCallback);
                    }
                    else {
                        reject(new Error('etag empty'));
                    }
                });
            })).then(() => {
                return;
            }); // void
        });
    }
    /**
     * Delete storage items from storage.
     *
     * @param keys Keys of the items to remove from the store.
     */
    delete(keys) {
        if (!keys || keys.length === 0) {
            return Promise.resolve();
        }
        let options;
        if (this.settings.partitionKey !== null) {
            options = {
                partitionKey: this.settings.partitionKey,
            };
        }
        return this.ensureCollectionExists()
            .then(() => Promise.all(keys.map((k) => new Promise((resolve, reject) => this.client.deleteDocument(documentdb_1.UriFactory.createDocumentUri(this.settings.databaseId, this.settings.collectionId, cosmosDbKeyEscape_1.CosmosDbKeyEscape.escapeKey(k)), options, (err) => (err && err.code !== 404 ? reject(err) : resolve())))))) // handle notfound as Ok
            .then(() => {
            return;
        }); // void
    }
    /**
     * Delayed Database and Collection creation if they do not exist.
     */
    ensureCollectionExists() {
        if (!this.collectionExists) {
            this.collectionExists = new Promise((resolve) => {
                _semaphore.take(() => {
                    const result = this.collectionExists
                        ? this.collectionExists
                        : getOrCreateDatabase(this.client, this.settings.databaseId, this.databaseCreationRequestOption).then((databaseLink) => getOrCreateCollection(this.client, databaseLink, this.settings.collectionId, this.documentCollectionCreationRequestOption));
                    _semaphore.leave();
                    resolve(result);
                });
            });
        }
        return this.collectionExists;
    }
}
exports.CosmosDbStorage = CosmosDbStorage;
/**
 * @private
 */
function getOrCreateDatabase(client, databaseId, databaseCreationRequestOption) {
    const querySpec = {
        query: 'SELECT r._self FROM root r WHERE r.id = @id',
        parameters: [{ name: '@id', value: databaseId }],
    };
    return new Promise((resolve, reject) => {
        client.queryDatabases(querySpec).toArray((err, results) => {
            if (err) {
                return reject(err);
            }
            if (results.length === 1) {
                return resolve(results[0]._self);
            }
            // create db
            client.createDatabase({ id: databaseId }, databaseCreationRequestOption, (dbCreateErr, databaseLink) => {
                if (dbCreateErr) {
                    return reject(dbCreateErr);
                }
                resolve(databaseLink._self);
            });
        });
    });
}
/**
 * @private
 */
function getOrCreateCollection(client, databaseLink, collectionId, documentCollectionCreationRequestOption) {
    const querySpec = {
        query: 'SELECT r._self FROM root r WHERE r.id=@id',
        parameters: [{ name: '@id', value: collectionId }],
    };
    return new Promise((resolve, reject) => {
        client.queryCollections(databaseLink, querySpec).toArray((err, results) => {
            if (err) {
                return reject(err);
            }
            if (results.length === 1) {
                return resolve(results[0]._self);
            }
            client.createCollection(databaseLink, { id: collectionId }, documentCollectionCreationRequestOption, (err2, collectionLink) => {
                if (err2) {
                    return reject(err2);
                }
                resolve(collectionLink._self);
            });
        });
    });
}
//# sourceMappingURL=cosmosDbStorage.js.map