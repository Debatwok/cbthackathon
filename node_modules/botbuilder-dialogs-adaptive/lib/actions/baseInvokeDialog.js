"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInvokeDialog = void 0;
const expressions_1 = require("../expressions");
const converters_1 = require("../converters");
const jsonExtensions_1 = require("../jsonExtensions");
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
/**
 * Action which calls another [Dialog](xref:botbuilder-dialogs.Dialog).
 */
class BaseInvokeDialog extends botbuilder_dialogs_1.Dialog {
    constructor(dialogIdToCall, bindingOptions) {
        super();
        /**
         * Configurable options for the dialog.
         */
        this.options = new adaptive_expressions_1.ObjectExpression();
        /**
         * A value indicating whether to have the new dialog should process the activity.
         */
        this.activityProcessed = new adaptive_expressions_1.BoolExpression(true);
        if (dialogIdToCall) {
            this.dialog = new expressions_1.DialogExpression(dialogIdToCall);
        }
        if (bindingOptions) {
            this.options = new adaptive_expressions_1.ObjectExpression(bindingOptions);
        }
    }
    getConverter(property) {
        switch (property) {
            case 'options':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            case 'dialog':
                return converters_1.DialogExpressionConverter;
            case 'activityProcessed':
                return new adaptive_expressions_1.BoolExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Called when the [Dialog](xref:botbuilder-dialogs.Dialog) is started and pushed onto the dialog stack.
     * @remarks Method not implemented.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options Optional. Initial information to pass to the dialog.
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc, options) {
        throw new Error('Method not implemented.');
    }
    /**
     * Gets the child [Dialog](xref:botbuilder-dialogs.Dialog) dependencies so they can be added to the containers [Dialog](xref:botbuilder-dialogs.Dialog) set.
     * @returns The child [Dialog](xref:botbuilder-dialogs.Dialog) dependencies.
     */
    getDependencies() {
        if (this.dialog && this.dialog.value) {
            return [this.dialog.value];
        }
        return [];
    }
    /**
     * @protected
     * Builds the compute Id for the [Dialog](xref:botbuilder-dialogs.Dialog).
     * @returns A `string` representing the compute Id.
     */
    onComputeId() {
        return `${this.constructor.name}[${this.dialog && this.dialog.toString()}]`;
    }
    /**
     * @protected
     * Resolve Dialog Expression as either [Dialog](xref:botbuilder-dialogs.Dialog), or [StringExpression](xref:adaptive-expressions.StringExpression) to get `dialogid`.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     */
    resolveDialog(dc) {
        if (this.dialog && this.dialog.value) {
            return this.dialog.value;
        }
        const expression = this.dialog.toExpression();
        const { value: dialogId } = expression.tryEvaluate(dc.state);
        const dialog = dc.findDialog(dialogId);
        if (!dialog) {
            throw new Error(`${this.dialog.toString()} not found.`);
        }
        return dialog;
    }
    /**
     * @protected
     * BindOptions - evaluate expressions in options.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options Options to bind.
     * @returns The merged options with expressions bound to values.
     */
    bindOptions(dc, options) {
        const bindingOptions = Object.assign({}, this.options.getValue(dc.state), options);
        const boundOptions = {};
        for (const key in bindingOptions) {
            const bindingValue = bindingOptions[key];
            boundOptions[key] = jsonExtensions_1.evaluateExpression(dc.state, new adaptive_expressions_1.ValueExpression(bindingValue));
        }
        return boundOptions;
    }
}
exports.BaseInvokeDialog = BaseInvokeDialog;
//# sourceMappingURL=baseInvokeDialog.js.map