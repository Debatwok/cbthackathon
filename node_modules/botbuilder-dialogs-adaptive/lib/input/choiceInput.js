"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoiceInput = exports.ChoiceOutputFormat = void 0;
const choiceSet_1 = require("./choiceSet");
const inputDialog_1 = require("./inputDialog");
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
var ChoiceOutputFormat;
(function (ChoiceOutputFormat) {
    ChoiceOutputFormat["value"] = "value";
    ChoiceOutputFormat["index"] = "index";
})(ChoiceOutputFormat = exports.ChoiceOutputFormat || (exports.ChoiceOutputFormat = {}));
/**
 * ChoiceInput - Declarative input to gather choices from user.
 */
class ChoiceInput extends inputDialog_1.InputDialog {
    constructor() {
        super(...arguments);
        /**
         * List of choices to present to user.
         */
        this.choices = new adaptive_expressions_1.ObjectExpression();
        /**
         * Style of the "yes" and "no" choices rendered to the user when prompting.
         *
         * @remarks
         * Defaults to `ListStyle.auto`.
         */
        this.style = new adaptive_expressions_1.EnumExpression(botbuilder_dialogs_1.ListStyle.auto);
        /**
         * Control the format of the response (value or index of the choice).
         */
        this.outputFormat = new adaptive_expressions_1.EnumExpression(ChoiceOutputFormat.value);
        /**
         * Additional options passed to the `ChoiceFactory` and used to tweak the style of choices
         * rendered to the user.
         */
        this.choiceOptions = new adaptive_expressions_1.ObjectExpression();
        /**
         * Additional options passed to the underlying `recognizeChoices()` function.
         */
        this.recognizerOptions = new adaptive_expressions_1.ObjectExpression();
    }
    getConverter(property) {
        switch (property) {
            case 'choices':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            case 'style':
                return new adaptive_expressions_1.EnumExpressionConverter(botbuilder_dialogs_1.ListStyle);
            case 'defaultLocale':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'outputFormat':
                return new adaptive_expressions_1.EnumExpressionConverter(ChoiceOutputFormat);
            case 'choiceOptions':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            case 'recognizerOptions':
                return new adaptive_expressions_1.ObjectExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * @protected
     * Method which processes options.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options Optional, initial information to pass to the dialog.
     * @returns The modified [ChoiceInputOptions](xref:botbuilder-dialogs-adaptive.ChoiceInputOptions) options.
     */
    onInitializeOptions(dc, options) {
        const _super = Object.create(null, {
            onInitializeOptions: { get: () => super.onInitializeOptions }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!(options && options.choices && options.choices.length > 0)) {
                if (!options) {
                    options = { choices: [] };
                }
                options.choices = yield this.getChoiceSet(dc);
            }
            return yield _super.onInitializeOptions.call(this, dc, options);
        });
    }
    /**
     * @protected
     * Called when input has been received.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @returns [InputState](xref:botbuilder-dialogs-adaptive.InputState) which reflects whether input was recognized as valid or not.
     */
    onRecognizeInput(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get input and options
            const input = dc.state.getValue(inputDialog_1.InputDialog.VALUE_PROPERTY).toString();
            const options = dc.state.getValue(inputDialog_1.InputDialog.OPTIONS_PROPERTY);
            // Format choices
            const choices = botbuilder_dialogs_1.ChoiceFactory.toChoices(options.choices);
            // Initialize recognizer options
            const opt = Object.assign({}, this.recognizerOptions.getValue(dc.state));
            opt.locale = this.determineCulture(dc, opt);
            // Recognize input
            const results = botbuilder_dialogs_1.recognizeChoices(input, choices, opt);
            if (!Array.isArray(results) || results.length == 0) {
                return inputDialog_1.InputState.unrecognized;
            }
            // Format output and return success
            const foundChoice = results[0].resolution;
            switch (this.outputFormat.getValue(dc.state)) {
                case ChoiceOutputFormat.value:
                default:
                    dc.state.setValue(inputDialog_1.InputDialog.VALUE_PROPERTY, foundChoice.value);
                    break;
                case ChoiceOutputFormat.index:
                    dc.state.setValue(inputDialog_1.InputDialog.VALUE_PROPERTY, foundChoice.index);
                    break;
            }
            return inputDialog_1.InputState.valid;
        });
    }
    /**
     * @protected
     * Method which renders the prompt to the user given the current input state.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param state Dialog [InputState](xref:botbuilder-dialogs-adaptive.InputState).
     * @returns An [Activity](xref:botframework-schema.Activity) `Promise` representing the asynchronous operation.
     */
    onRenderPrompt(dc, state) {
        const _super = Object.create(null, {
            onRenderPrompt: { get: () => super.onRenderPrompt }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Determine locale
            const locale = this.determineCulture(dc);
            // Format prompt to send
            const prompt = yield _super.onRenderPrompt.call(this, dc, state);
            const channelId = dc.context.activity.channelId;
            const choiceOptions = (this.choiceOptions && this.choiceOptions.getValue(dc.state)) || ChoiceInput.defaultChoiceOptions[locale];
            const style = this.style.getValue(dc.state);
            const options = dc.state.getValue(ChoiceInput.OPTIONS_PROPERTY);
            return this.appendChoices(prompt, channelId, options.choices, style, choiceOptions);
        });
    }
    /**
     * @protected
     */
    onComputeId() {
        return `ChoiceInput[${this.prompt && this.prompt.toString()}]`;
    }
    getChoiceSet(dc) {
        if (this.choices.expressionText != null && this.choices.expressionText.trimLeft().startsWith('${')) {
            // use TemplateInterface to bind (aka LG)
            const choiceSet = new choiceSet_1.ChoiceSet(this.choices.expressionText);
            return choiceSet.bind(dc, dc.state);
        }
        else {
            // use Expression to bind
            return Promise.resolve(this.choices.getValue(dc.state));
        }
    }
    determineCulture(dc, opt) {
        var _a, _b, _c;
        /**
         * @deprecated Note: opt.Locale and Default locale will be considered for deprecation as part of 4.13.
         */
        const candidateLocale = (_b = (_a = dc.getLocale()) !== null && _a !== void 0 ? _a : opt === null || opt === void 0 ? void 0 : opt.locale) !== null && _b !== void 0 ? _b : (_c = this.defaultLocale) === null || _c === void 0 ? void 0 : _c.getValue(dc.state);
        let culture = botbuilder_dialogs_1.PromptCultureModels.mapToNearestLanguage(candidateLocale);
        if (!(culture && ChoiceInput.defaultChoiceOptions.hasOwnProperty(culture))) {
            culture = botbuilder_dialogs_1.PromptCultureModels.English.locale;
        }
        return culture;
    }
}
exports.ChoiceInput = ChoiceInput;
ChoiceInput.$kind = 'Microsoft.ChoiceInput';
/**
 * Default options for rendering the choices to the user based on locale.
 */
ChoiceInput.defaultChoiceOptions = {
    'es-es': { inlineSeparator: ', ', inlineOr: ' o ', inlineOrMore: ', o ', includeNumbers: true },
    'nl-nl': { inlineSeparator: ', ', inlineOr: ' of ', inlineOrMore: ', of ', includeNumbers: true },
    'en-us': { inlineSeparator: ', ', inlineOr: ' or ', inlineOrMore: ', or ', includeNumbers: true },
    'fr-fr': { inlineSeparator: ', ', inlineOr: ' ou ', inlineOrMore: ', ou ', includeNumbers: true },
    'de-de': { inlineSeparator: ', ', inlineOr: ' oder ', inlineOrMore: ', oder ', includeNumbers: true },
    'ja-jp': { inlineSeparator: '、 ', inlineOr: ' または ', inlineOrMore: '、 または ', includeNumbers: true },
    'pt-br': { inlineSeparator: ', ', inlineOr: ' ou ', inlineOrMore: ', ou ', includeNumbers: true },
    'zh-cn': { inlineSeparator: '， ', inlineOr: ' 要么 ', inlineOrMore: '， 要么 ', includeNumbers: true },
};
//# sourceMappingURL=choiceInput.js.map