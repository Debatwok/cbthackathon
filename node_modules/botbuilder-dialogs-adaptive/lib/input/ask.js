"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ask = void 0;
const sendActivity_1 = require("../actions/sendActivity");
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const botbuilder_1 = require("botbuilder");
const __1 = require("..");
/**
 * Ask for an open-ended response.
 * This sends an activity and then terminates the turn with `DialogTurnStatus.completeAndWait`.
 * The next activity from the user will then be handled by the parent adaptive dialog.
 * It also builds in a model of the properties that are expected in response through `DialogPath.expectedProperties`.
 * `DialogPath.retries` is updated as the same question is asked multiple times.
 */
class Ask extends sendActivity_1.SendActivity {
    /**
     *Initializes a new instance of the [Ask](xref:botbuilder-dialogs-adaptive.Ask) class.
     * @param text Optional, text value.
     * @param expectedProperties Optional, [ArrayExpression](xref:adaptive-expressions.ArrayExpression) of expected properties.
     */
    constructor(text, expectedProperties) {
        super(text);
        this.expectedProperties = expectedProperties;
    }
    /**
     * Called when the [Dialog](xref:botbuilder-dialogs.Dialog) is started and pushed onto the dialog stack.
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options Optional, initial information to pass to the [Dialog](xref:botbuilder-dialogs.Dialog).
     * @param property
     * @returns A [DialogTurnResult](xref:botbuilder-dialogs.DialogTurnResult) `Promise` representing the asynchronous operation.
     */
    getConverter(property) {
        switch (property) {
            case 'expectedProperties':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'defaultOperation':
                return new adaptive_expressions_1.StringExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    beginDialog(dc, options) {
        const _super = Object.create(null, {
            beginDialog: { get: () => super.beginDialog }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // get number of retries from memory
            let retries = dc.state.getValue(botbuilder_dialogs_1.DialogPath.retries, 0);
            const expected = this.expectedProperties ? this.expectedProperties.getValue(dc.state) : undefined;
            const trigger = dc.state.getValue(botbuilder_dialogs_1.TurnPath.dialogEvent);
            const lastExpectedProperties = dc.state.getValue(botbuilder_dialogs_1.DialogPath.expectedProperties);
            const lastTrigger = dc.state.getValue(botbuilder_dialogs_1.DialogPath.lastTriggerEvent);
            if (expected &&
                lastExpectedProperties &&
                lastTrigger &&
                !expected.some((prop) => !lastExpectedProperties.some((lastProp) => lastProp === prop)) &&
                !lastExpectedProperties.some((lastProp) => !expected.some((prop) => prop === lastProp)) &&
                lastTrigger.name === trigger.name) {
                retries++;
            }
            else {
                retries = 0;
            }
            dc.state.setValue(botbuilder_dialogs_1.DialogPath.retries, retries);
            dc.state.setValue(botbuilder_dialogs_1.DialogPath.lastTriggerEvent, trigger);
            dc.state.setValue(botbuilder_dialogs_1.DialogPath.expectedProperties, expected);
            const result = yield _super.beginDialog.call(this, dc, options);
            result.status = botbuilder_dialogs_1.DialogTurnStatus.completeAndWait;
            return result;
        });
    }
    onComputeId() {
        if (this.activity instanceof __1.ActivityTemplate) {
            return `Ask[${botbuilder_1.StringUtils.ellipsis(this.activity.template.trim(), 30)}]`;
        }
        return `Ask[${botbuilder_1.StringUtils.ellipsis(this.activity && this.activity.toString().trim(), 30)}]`;
    }
}
exports.Ask = Ask;
Ask.$kind = 'Microsoft.Ask';
//# sourceMappingURL=ask.js.map