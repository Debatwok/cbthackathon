"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionContext = void 0;
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const actionChangeType_1 = require("./actionChangeType");
/**
 * Extends the [DialogContext](xref:botbuilder-dialogs.DialogContext) with additional methods for manipulating the
 * executing sequence of actions for an [AdaptiveDialog](xref:botbuilder-dialogs-adaptive.AdaptiveDialog).
 */
class ActionContext extends botbuilder_dialogs_1.DialogContext {
    /**
     * Initializes a new instance of the [ActionContext](xref:botbuilder-dialogs-adaptive.ActionContext) class
     * @param dialogs The dialog set to create the action context for.
     * @param parentDialogContext Parent dialog context.
     * @param state Current dialog state.
     * @param actions Current list of remaining actions to execute.
     * @param changeKey TurnState key for where to persist any changes.
     */
    constructor(dialogs, parentDialogContext, state, actions, changeKey) {
        super(dialogs, parentDialogContext, state);
        this.actions = actions;
        this._changeKey = changeKey;
    }
    /**
     * Gets list of changes that are queued to be applied.
     */
    get changes() {
        return this.context.turnState.get(this._changeKey) || [];
    }
    /**
     * Queues up a set of changes that will be applied when applyChanges() is called.
     * @param changes Plan changes to queue up.
     */
    queueChanges(changes) {
        const queue = this.changes;
        queue.push(changes);
        this.context.turnState.set(this._changeKey, queue);
    }
    /**
     * Applies any queued up changes.
     */
    applyChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve queued change list
            const changes = this.changes;
            if (changes.length > 0) {
                // Clear current change list
                this.context.turnState.delete(this._changeKey);
                // Apply each queued set of changes
                for (let i = 0; i < changes.length; i++) {
                    const change = changes[i];
                    // Apply memory changes to turn state
                    if (change.turn) {
                        for (const key in change.turn) {
                            this.state.setValue(`turn.${key}`, change.turn[key]);
                        }
                    }
                    // Update sequence
                    switch (change.changeType) {
                        case actionChangeType_1.ActionChangeType.insertActions:
                            this.actions.unshift(...change.actions);
                            break;
                        case actionChangeType_1.ActionChangeType.appendActions:
                            this.actions.push(...change.actions);
                            break;
                        case actionChangeType_1.ActionChangeType.endSequence:
                            if (this.actions.length > 0) {
                                this.actions.splice(0, this.actions.length);
                            }
                            break;
                        case actionChangeType_1.ActionChangeType.replaceSequence:
                            if (this.actions.length > 0) {
                                this.actions.splice(0, this.actions.length);
                            }
                            this.actions.push(...change.actions);
                            break;
                    }
                }
                // Apply any queued up changes
                yield this.applyChanges();
                return true;
            }
            return false;
        });
    }
}
exports.ActionContext = ActionContext;
//# sourceMappingURL=actionContext.js.map