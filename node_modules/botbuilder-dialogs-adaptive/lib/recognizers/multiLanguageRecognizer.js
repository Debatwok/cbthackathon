"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiLanguageRecognizer = void 0;
const languagePolicy_1 = require("../languagePolicy");
const converters_1 = require("../converters");
const languageGeneratorExtensions_1 = require("../languageGeneratorExtensions");
const adaptiveRecognizer_1 = require("./adaptiveRecognizer");
class MultiLanguageRecognizer extends adaptiveRecognizer_1.AdaptiveRecognizer {
    getConverter(property) {
        switch (property) {
            case 'languagePolicy':
                return new languagePolicy_1.LanguagePolicyConverter();
            case 'recognizers':
                return converters_1.MultiLanguageRecognizerConverter;
            default:
                return super.getConverter(property);
        }
    }
    recognize(dialogContext, activity, telemetryProperties, telemetryMetrics) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let languagepolicy = this.languagePolicy;
            if (!languagepolicy) {
                languagepolicy = dialogContext.services.get(languageGeneratorExtensions_1.languagePolicyKey);
                if (!languagepolicy) {
                    languagepolicy = new languagePolicy_1.LanguagePolicy();
                }
            }
            const locale = ((_a = activity.locale) !== null && _a !== void 0 ? _a : '').toLowerCase();
            const policy = [];
            if (languagepolicy.has(locale)) {
                languagepolicy.get(locale).forEach((u) => policy.push(u));
            }
            if (locale !== '' && languagepolicy.has('')) {
                // we now explictly add defaultPolicy instead of coding that into target's policy
                languagepolicy.get('').forEach((u) => policy.push(u));
            }
            for (let i = 0; i < policy.length; i++) {
                const option = policy[i];
                if (this.recognizers.hasOwnProperty(option)) {
                    const recognizer = this.recognizers[option];
                    const result = yield recognizer.recognize(dialogContext, activity, telemetryProperties, telemetryMetrics);
                    this.trackRecognizerResult(dialogContext, 'MultiLanguageRecognizerResult', this.fillRecognizerResultTelemetryProperties(result, telemetryProperties, dialogContext), telemetryMetrics);
                    return result;
                }
            }
            const recognizerResult = {
                text: activity.text || '',
                intents: {},
                entities: {},
            };
            this.trackRecognizerResult(dialogContext, 'MultiLanguagesRecognizerResult', this.fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dialogContext), telemetryMetrics);
            return recognizerResult;
        });
    }
}
exports.MultiLanguageRecognizer = MultiLanguageRecognizer;
MultiLanguageRecognizer.$kind = 'Microsoft.MultiLanguageRecognizer';
//# sourceMappingURL=multiLanguageRecognizer.js.map